(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{629:function(a,t,s){"use strict";s.r(t);var n=s(5),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"第-8-章-数组的扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第-8-章-数组的扩展"}},[a._v("#")]),a._v(" 第 8 章_数组的扩展")]),a._v(" "),s("h2",{attrs:{id:"一、扩展运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、扩展运算符"}},[a._v("#")]),a._v(" 一、扩展运算符")]),a._v(" "),s("ol",[s("li",[a._v("含义：扩展运算符（spread）是三个点（"),s("code",[a._v("...")]),a._v("），将一个数组转为用逗号分隔的参数序列。")]),a._v(" "),s("li",[a._v("由于扩展运算符可以展开数组，所以不再需要"),s("code",[a._v("apply")]),a._v("方法，将数组转为函数的参数了。")]),a._v(" "),s("li",[a._v("应用\n"),s("ul",[s("li",[a._v("复制数组")]),a._v(" "),s("li",[a._v("合并数组")]),a._v(" "),s("li",[a._v("与解构赋值结合，生成数组")]),a._v(" "),s("li",[a._v("函数的返回值")]),a._v(" "),s("li",[a._v("字符串")]),a._v(" "),s("li",[a._v("实现了 Iterator 接口的对象")]),a._v(" "),s("li",[a._v("Map 和 Set 结构，Generator 函数")])])])]),a._v(" "),s("h2",{attrs:{id:"二、array-from"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、array-from"}},[a._v("#")]),a._v(" 二、Array.from")]),a._v(" "),s("ol",[s("li",[a._v("将两类对象转为真正的数组**：类似数组的对象（array-like object，有 length 属性）"),s("strong",[a._v("和")]),a._v("可遍历（iterable）的对象**（包括 ES6 新增的数据结构 Set 和 Map）。")]),a._v(" "),s("li",[a._v("第二个参数，作用类似于数组的"),s("code",[a._v("map")]),a._v("方法，用来对每个元素进行处理，将处理后的值放入返回的数组。")]),a._v(" "),s("li",[a._v("第三个参数，用来绑定"),s("code",[a._v("this")]),a._v("。（如果"),s("code",[a._v("map")]),a._v("函数里面用到了"),s("code",[a._v("this")]),a._v("关键字）")]),a._v(" "),s("li",[a._v("另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于"),s("code",[a._v("\\uFFFF")]),a._v("的 Unicode 字符，算作两个字符的 bug。")]),a._v(" "),s("li",[a._v("与扩展运算符的区别\n"),s("ul",[s("li",[s("code",[a._v("...")]),a._v("背后调用的是遍历器接口（"),s("code",[a._v("Symbol.iterator")]),a._v("），如果一个对象没有部署这个接口，就无法转换。")]),a._v(" "),s("li",[s("code",[a._v("Array.from")]),a._v("方法还支持类似数组的对象。")])])]),a._v(" "),s("li",[a._v("对于还没有部署该方法的浏览器，可以用"),s("code",[a._v("Array.prototype.slice")]),a._v("方法替代。"),s("code",[a._v("[].slice.call(obj)")])])]),a._v(" "),s("h2",{attrs:{id:"三、array-of"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、array-of"}},[a._v("#")]),a._v(" 三、Array.of()")]),a._v(" "),s("ol",[s("li",[a._v("将一组值，转换为数组。弥补数组构造函数"),s("code",[a._v("Array()")]),a._v("的不足。因为参数个数的不同，会导致"),s("code",[a._v("Array()")]),a._v("的行为有差异。")]),a._v(" "),s("li",[a._v("返回参数值组成的数组。如果没有参数，就返回一个空数组。")])]),a._v(" "),s("h2",{attrs:{id:"四、数组实例的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、数组实例的方法"}},[a._v("#")]),a._v(" 四、数组实例的方法")]),a._v(" "),s("h3",{attrs:{id:"copywithin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#copywithin"}},[a._v("#")]),a._v(" "),s("code",[a._v("copyWithin()")])]),a._v(" "),s("ul",[s("li",[a._v("在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，修改当前数组。")]),a._v(" "),s("li",[a._v("三个参数：\n"),s("ul",[s("li",[a._v("target（必需）：从该位置开始替换数据。如果为负值，表示倒数。")]),a._v(" "),s("li",[a._v("start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。")]),a._v(" "),s("li",[a._v("end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。")])])])]),a._v(" "),s("h3",{attrs:{id:"find"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#find"}},[a._v("#")]),a._v(" "),s("code",[a._v("find()")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("返回第一个符合条件的数组成员。")])]),a._v(" "),s("li",[s("p",[a._v("第一个参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为"),s("code",[a._v("true")]),a._v("的成员，然后返回该成员。如果没有符合条件的成员，则返回"),s("code",[a._v("undefined")]),a._v("。")])]),a._v(" "),s("li",[s("p",[a._v("可以接受第二个参数，用来绑定回调函数的"),s("code",[a._v("this")]),a._v("对象。")])]),a._v(" "),s("li",[s("p",[a._v("回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。")])]),a._v(" "),s("li",[s("p",[a._v("可以发现"),s("code",[a._v("NaN")]),a._v("，弥补了数组的"),s("code",[a._v("indexOf")]),a._v("方法的不足。")]),a._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("indexOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// -1")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])])])]),a._v(" "),s("h3",{attrs:{id:"findindex"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#findindex"}},[a._v("#")]),a._v(" "),s("code",[a._v("findIndex()")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("返回第一个符合条件的数组成员的位置。")])]),a._v(" "),s("li",[s("p",[a._v("第一个参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为"),s("code",[a._v("true")]),a._v("的成员，然后返回该成员的位置。如果没有符合条件的成员，则返回"),s("code",[a._v("-1")]),a._v("。")])]),a._v(" "),s("li",[s("p",[a._v("可以接受第二个参数，用来绑定回调函数的"),s("code",[a._v("this")]),a._v("对象。")])]),a._v(" "),s("li",[s("p",[a._v("回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。")])]),a._v(" "),s("li",[s("p",[a._v("可以发现"),s("code",[a._v("NaN")]),a._v("，弥补了数组的"),s("code",[a._v("indexOf")]),a._v("方法的不足。")]),a._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("findIndex")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("y")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("is")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 0")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])])])]),a._v(" "),s("h3",{attrs:{id:"fill"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fill"}},[a._v("#")]),a._v(" "),s("code",[a._v("fill()")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("使用给定值，填充一个数组。")])]),a._v(" "),s("li",[s("p",[a._v("第一个参数给定值。")])]),a._v(" "),s("li",[s("p",[a._v("可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。")])]),a._v(" "),s("li",[s("p",[a._v("注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。")]),a._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" arr "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("fill")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" name"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Mike'")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\narr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Ben'")]),a._v("\narr\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]')]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" arr "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("fill")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\narr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\narr\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// [[5], [5], [5]]")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])])])]),a._v(" "),s("h3",{attrs:{id:"entries-keys-和values"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#entries-keys-和values"}},[a._v("#")]),a._v(" "),s("code",[a._v("entries()")]),a._v("，"),s("code",[a._v("keys()")]),a._v("和"),s("code",[a._v("values()")])]),a._v(" "),s("ul",[s("li",[a._v("用于遍历数组，都返回一个遍历器对象，可以用"),s("code",[a._v("for...of")]),a._v("循环进行遍历。")]),a._v(" "),s("li",[s("code",[a._v("keys()")]),a._v("是对键名的遍历、"),s("code",[a._v("values()")]),a._v("是对键值的遍历，"),s("code",[a._v("entries()")]),a._v("是对键值对的遍历。")])]),a._v(" "),s("h3",{attrs:{id:"includes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#includes"}},[a._v("#")]),a._v(" "),s("code",[a._v("includes()")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("返回一个布尔值，表示某个数组是否包含给定的值。")])]),a._v(" "),s("li",[s("p",[a._v("第一个参数给定值。")])]),a._v(" "),s("li",[s("p",[a._v("可以接受第二个参数，表示搜索的起始位置，默认为"),s("code",[a._v("0")]),a._v("。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为"),s("code",[a._v("-4")]),a._v("，但数组长度为"),s("code",[a._v("3")]),a._v("），则会重置为从"),s("code",[a._v("0")]),a._v("开始。")])]),a._v(" "),s("li",[s("p",[s("code",[a._v("indexOf")]),a._v("方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于"),s("code",[a._v("-1")]),a._v("，表达起来不够直观。二是，它内部使用严格相等运算符（"),s("code",[a._v("===")]),a._v("）进行判断，这会导致对"),s("code",[a._v("NaN")]),a._v("的误判。")]),a._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("indexOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// -1")]),a._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("includes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])])])]),a._v(" "),s("h3",{attrs:{id:"flat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flat"}},[a._v("#")]),a._v(" "),s("code",[a._v("flat()")])]),a._v(" "),s("ul",[s("li",[a._v("将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。")]),a._v(" "),s("li",[a._v("参数写成一个整数，表示想要拉平的层数，默认为 1。Infinity 表示不管有多少层嵌套，都要转成一维数组。")]),a._v(" "),s("li",[a._v("如果原数组有空位，"),s("code",[a._v("flat()")]),a._v("方法会跳过空位。")])]),a._v(" "),s("h3",{attrs:{id:"flatmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flatmap"}},[a._v("#")]),a._v(" "),s("code",[a._v("flatMap()")])]),a._v(" "),s("ul",[s("li",[a._v("对原数组的每个成员执行一个函数（相当于执行"),s("code",[a._v("map()")]),a._v("），然后对返回值组成的数组执行"),s("code",[a._v("flat()")]),a._v("方法，只能展开一层数组。。")]),a._v(" "),s("li",[a._v("第一个参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。")]),a._v(" "),s("li",[a._v("可以有第二个参数，用来绑定遍历函数里面的"),s("code",[a._v("this")]),a._v("。")])]),a._v(" "),s("h2",{attrs:{id:"五、数组的空位"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、数组的空位"}},[a._v("#")]),a._v(" 五、数组的空位")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("数组的空位指，数组的某一个位置没有任何值。")])]),a._v(" "),s("li",[s("p",[a._v("空位不是"),s("code",[a._v("undefined")]),a._v("，一个位置的值等于"),s("code",[a._v("undefined")]),a._v("，依然是有值的。")]),a._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("in")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("undefined")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("undefined")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("undefined")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("in")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// false")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])])]),a._v(" "),s("li",[s("p",[a._v("ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("forEach()")]),a._v(", "),s("code",[a._v("filter()")]),a._v(", "),s("code",[a._v("reduce()")]),a._v(", "),s("code",[a._v("every()")]),a._v(" 和"),s("code",[a._v("some()")]),a._v("都会跳过空位。")]),a._v(" "),s("li",[s("code",[a._v("map()")]),a._v("会跳过空位，但会保留这个值")]),a._v(" "),s("li",[s("code",[a._v("join()")]),a._v("和"),s("code",[a._v("toString()")]),a._v("会将空位视为"),s("code",[a._v("undefined")]),a._v("，而"),s("code",[a._v("undefined")]),a._v("和"),s("code",[a._v("null")]),a._v("会被处理成空字符串。")])])]),a._v(" "),s("li",[s("p",[a._v("ES6 则是明确将空位转为"),s("code",[a._v("undefined")]),a._v("。")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("Array.from")]),a._v("方法会将数组的空位，转为"),s("code",[a._v("undefined")]),a._v("，也就是说，这个方法不会忽略空位。")]),a._v(" "),s("li",[a._v("扩展运算符（"),s("code",[a._v("...")]),a._v("）也会将空位转为"),s("code",[a._v("undefined")]),a._v("。")]),a._v(" "),s("li",[s("code",[a._v("copyWithin()")]),a._v("会连空位一起拷贝。")]),a._v(" "),s("li",[s("code",[a._v("fill()")]),a._v("会将空位视为正常的数组位置。")]),a._v(" "),s("li",[s("code",[a._v("for...of")]),a._v("循环也会遍历空位。")]),a._v(" "),s("li",[s("code",[a._v("entries()")]),a._v("、"),s("code",[a._v("keys()")]),a._v("、"),s("code",[a._v("values()")]),a._v("、"),s("code",[a._v("find()")]),a._v("和"),s("code",[a._v("findIndex()")]),a._v("会将空位处理成"),s("code",[a._v("undefined")]),a._v("。")])])]),a._v(" "),s("li",[s("p",[a._v("由于空位的处理规则非常不统一，所以建议避免出现空位。")])])]),a._v(" "),s("h2",{attrs:{id:"六、array-prototype-sort"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、array-prototype-sort"}},[a._v("#")]),a._v(" 六、Array.prototype.sort()")]),a._v(" "),s("ol",[s("li",[a._v("排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。")]),a._v(" "),s("li",[a._v("常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。")]),a._v(" "),s("li",[a._v("早先的 ECMAScript 没有规定，"),s("code",[a._v("Array.prototype.sort()")]),a._v("的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。")]),a._v(" "),s("li",[a._v("ES2019 明确规定，"),s("code",[a._v("Array.prototype.sort()")]),a._v("的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);