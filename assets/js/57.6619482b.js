(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{618:function(t,s,a){"use strict";a.r(s);var n=a(5),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"垃圾回收与内存泄露"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收与内存泄露"}},[t._v("#")]),t._v(" 垃圾回收与内存泄露")]),t._v(" "),a("h2",{attrs:{id:"_1、垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、垃圾回收"}},[t._v("#")]),t._v(" 1、垃圾回收")]),t._v(" "),a("p",[t._v("找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔周期性地执行这一操作。")]),t._v(" "),a("p",[t._v("JavaScript 是一门具有自动垃圾收集机制的编程语言，因此开发人员不必关心内存分配和回收问题。")]),t._v(" "),a("p",[t._v("JS 环境中分配的内存一般有如下生命周期：")]),t._v(" "),a("ol",[a("li",[t._v("内存分配：当我们申明变量、函数、对象，并执行的时候，系统会自动为他们分配内存")]),t._v(" "),a("li",[t._v("内存使用：即读写内存，也就是使用变量、函数等")]),t._v(" "),a("li",[t._v("内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存")])]),t._v(" "),a("h3",{attrs:{id:"_1-1-标记清除算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-标记清除算法"}},[t._v("#")]),t._v(" 1.1 标记清除算法")]),t._v(" "),a("p",[t._v("JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。")]),t._v(" "),a("p",[t._v("该算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将"),a("strong",[t._v("定期从根开始")]),t._v("扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("标记阶段")]),t._v("，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("清除阶段")]),t._v("，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。")])])]),t._v(" "),a("p",[a("strong",[t._v("缺点")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("那些无法从根对象查询到的对象都将被清除")]),t._v(" "),a("li",[t._v("垃圾收集后有可能会造成大量的内存碎片")])]),t._v(" "),a("h3",{attrs:{id:"_1-2-引用计数算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-引用计数算法"}},[t._v("#")]),t._v(" 1.2 引用计数算法")]),t._v(" "),a("p",[t._v("最初级的垃圾收集算法。现在已经没有浏览器会用这种算法。这个算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。")]),t._v(" "),a("p",[t._v("引用计数就是记录每个变量被引用的次数，如果次数为 0，就回收变量。")]),t._v(" "),a("p",[a("strong",[t._v("缺点")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("无法处理循环引用。如果两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。")])]),t._v(" "),a("h3",{attrs:{id:"_1-3-chrome-v8-垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-chrome-v8-垃圾回收算法"}},[t._v("#")]),t._v(" 1.3 Chrome V8 垃圾回收算法")]),t._v(" "),a("p",[t._v("Chrome 浏览器的 V8 引擎采用的是分代回收策略。在 V8 中，将内存分为新生代和老生代，"),a("strong",[t._v("新生代内存 存储的为存活时间较短的对象")]),t._v("，"),a("strong",[t._v("老生代内存 存储的为存活时间较长或常驻内存的对象")]),t._v("。然后分别对不同分代的内存施以更高效的算法。")]),t._v(" "),a("p",[t._v("目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（"),a("strong",[t._v("新生代")]),t._v("），少回收「持久对象区」（"),a("strong",[t._v("老生代")]),t._v("），减少每次需遍历的对象，从而减少每次垃圾回收的耗时。")]),t._v(" "),a("p",[a("strong",[t._v("新生代算法")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("Scavenge 算法。是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态**。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间**。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而(From 空间内的)非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换("),a("strong",[t._v("即以前的 From 空间释放后变为 To;To 空间在复制存活的对象后,变为 From 空间")]),t._v(")。简而言之，在垃圾回收过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。")]),t._v(" "),a("li",[t._v("优点：由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它"),a("strong",[t._v("在时间效率上有优异的表现")]),t._v("。")]),t._v(" "),a("li",[t._v("缺点：只能使用堆内存中的一半")])]),t._v(" "),a("p",[a("strong",[t._v("晋升")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理**。对象从新生代中移动到老生代中的过程称为晋升**。")]),t._v(" "),a("li",[t._v("晋升的条件主要有两个：一个是对象是否经历过 Scavenge 回收，一个是 To 空间的内存占用比超过 25%限制。")])]),t._v(" "),a("p",[a("strong",[t._v("老生代算法")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("标记清除算法**。在标记阶段遍历堆中所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象**。")]),t._v(" "),a("li",[t._v("缺点：在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现"),a("strong",[t._v("需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的")]),t._v("。")]),t._v(" "),a("li",[t._v("解决：标记整理。对象在标记为死亡后，"),a("strong",[t._v("在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存")]),t._v("。")])]),t._v(" "),a("p",[a("strong",[t._v("增量式标记回收")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("“全停顿”"),a("strong",[t._v("：垃圾回收需要将应用逻辑暂停下来")]),t._v("，待执行完垃圾回收后再恢复执行应用逻辑。V8 的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。")]),t._v(" "),a("li",[t._v("为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是"),a("strong",[t._v("拆分为许多小“步进”，每做完一“步进”就让 js 应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"_1-4-垃圾回收算法比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-垃圾回收算法比较"}},[t._v("#")]),t._v(" 1.4 垃圾回收算法比较")]),t._v(" "),a("p",[a("strong",[t._v("Mark-Sweep、Mark-Compact、Scavenge 三种主要垃圾回收算法的简单对比")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("回收算法")]),t._v(" "),a("th",[t._v("Mark-Sweep")]),t._v(" "),a("th",[t._v("Mark-Compact")]),t._v(" "),a("th",[t._v("Scavenge")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("速度")]),t._v(" "),a("td",[t._v("中等")]),t._v(" "),a("td",[t._v("最慢")]),t._v(" "),a("td",[t._v("最快")])]),t._v(" "),a("tr",[a("td",[t._v("空间开销")]),t._v(" "),a("td",[t._v("少（有碎片）")]),t._v(" "),a("td",[t._v("少（无碎片）")]),t._v(" "),a("td",[t._v("双倍空间（无碎片）")])]),t._v(" "),a("tr",[a("td",[t._v("是否移动对象")]),t._v(" "),a("td",[t._v("否")]),t._v(" "),a("td",[t._v("是")]),t._v(" "),a("td",[t._v("是")])])])]),t._v(" "),a("h2",{attrs:{id:"_2、内存泄露"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、内存泄露"}},[t._v("#")]),t._v(" 2、内存泄露")]),t._v(" "),a("p",[t._v("当一块内存不再用到，但是垃圾回收机制又无法释放这块内存的时候，就导致内存泄漏。减少了可用内存数量从而降低计算机性能，严重的可能导致设备停止正常工作，或者应用程序崩溃。")]),t._v(" "),a("h3",{attrs:{id:"_2-1-内存泄露的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-内存泄露的原因"}},[t._v("#")]),t._v(" 2.1 内存泄露的原因")]),t._v(" "),a("ul",[a("li",[t._v("意外的全局变量")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bar "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// bar没被声明，会变成一个全局变量，在页面关闭之前不会被释放，使用严格模式可以避免")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'bar没有被声明!'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("ul",[a("li",[t._v("dom 清空时，还存在引用")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" element "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  shotCat"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'shotCat'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\ndocument"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("removeChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'shotCat'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果element没有被回收，这里移除了 shotCat 节点也是没用的，shotCat 节点依然留存在内存中.")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("与此类似情景还有：DOM 节点绑定了事件，但是在移除的时候没有解除事件绑定，那么仅仅移除 DOM 节点也是没用的。")]),t._v(" "),a("ul",[a("li",[t._v("定时器没有清除")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" someResource "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setInterval")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" node "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Node'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerHTML "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someResource"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果没有清除定时器，那么 someResource 就不会被释放，如果刚好它又占用了较大内存，就会引发性能问题.")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("但是 "),a("strong",[t._v("setTimeout ，它计时结束后它的回调里面引用的对象占用的内存是可以被回收的")]),t._v("。 当然有些场景 setTimeout 的计时可能很长,，这样的情况下也是需要纳入考虑的。")]),t._v(" "),a("ul",[a("li",[t._v("不规范地使用闭包")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fn "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" bar\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" bar\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// bar和a形成了相互循环引用")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br")])]),a("p",[t._v("可能有人说 bar 里不使用 console.log(a)不就没有引用了吗就不会造成内存泄露了。NONONO，"),a("strong",[t._v("bar 作为一个闭包，即使它内部什么都没有，foo 中的所有变量都还是隐式地被 bar 所引用")]),t._v("。 "),a("strong",[t._v("即使 bar 内什么都没有还是造成了循环引用")]),t._v("。解决办法就是，不要将 a.fn = bar。")]),t._v(" "),a("h3",{attrs:{id:"_2-2-避免策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-避免策略"}},[t._v("#")]),t._v(" 2.2 避免策略")]),t._v(" "),a("ul",[a("li",[t._v("减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收("),a("strong",[t._v("即赋值为 null")]),t._v(")；")]),t._v(" "),a("li",[t._v("注意程序逻辑，避免“死循环”之类的 ；")]),t._v(" "),a("li",[t._v("避免创建过多的对象原则**：不用了的东西要记得及时归还**。")]),t._v(" "),a("li",[t._v("减少层级过多的引用")])]),t._v(" "),a("h3",{attrs:{id:"_2-3-检测和处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-检测和处理"}},[t._v("#")]),t._v(" 2.3 检测和处理")]),t._v(" "),a("p",[a("strong",[t._v("检测")]),t._v("：Chrome 的开发者工具 timeline 检测内存占用或 profiles 来进行快照对比。Node 提供的"),a("code",[t._v("process.memoryUsage()")]),t._v("方法来检查内存泄露。")]),t._v(" "),a("p",[a("strong",[t._v("处理")]),t._v("：及时对无用的数据进行垃圾回收。减少使用不必要的全局变量或生命周期较长的变量。变量导致的内存泄露，将变量清除 a = null 即可。事件监听导致的内存泄露，监听后移除即可。")])])}),[],!1,null,null,null);s.default=r.exports}}]);