(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{626:function(t,_,v){"use strict";v.r(_);var s=v(5),a=Object(s.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"第-18-章-class"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第-18-章-class"}},[t._v("#")]),t._v(" 第 18 章_Class")]),t._v(" "),v("h2",{attrs:{id:"一、概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、概述"}},[t._v("#")]),t._v(" 一、概述")]),t._v(" "),v("ol",[v("li",[t._v("ES6 的类，完全可以看作构造函数的另一种写法。类的数据类型就是函数，类本身就指向构造函数。")]),t._v(" "),v("li",[t._v("类的所有方法都定义在类的"),v("code",[t._v("prototype")]),t._v("属性上面。")]),t._v(" "),v("li",[t._v("类的内部所有定义的方法，都是不可枚举的。")]),t._v(" "),v("li",[t._v("类不存在变量提升。")])]),t._v(" "),v("h2",{attrs:{id:"二、constructor-方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、constructor-方法"}},[t._v("#")]),t._v(" 二、constructor 方法")]),t._v(" "),v("ol",[v("li",[v("code",[t._v("constructor()")]),t._v("方法是类的默认方法，通过"),v("code",[t._v("new")]),t._v("命令生成对象实例时，自动调用该方法。")]),t._v(" "),v("li",[v("code",[t._v("constructor()")]),t._v("方法默认返回实例对象（即"),v("code",[t._v("this")]),t._v("），完全可以指定返回另外一个对象。")])]),t._v(" "),v("h2",{attrs:{id:"三、类的实例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、类的实例"}},[t._v("#")]),t._v(" 三、类的实例")]),t._v(" "),v("ol",[v("li",[t._v("实例的属性除非显式定义在其本身（即定义在"),v("code",[t._v("this")]),t._v("对象上），否则都是定义在原型上。")]),t._v(" "),v("li",[t._v("类的所有实例共享一个原型对象。")])]),t._v(" "),v("h2",{attrs:{id:"四、取值函数-getter-和存值函数-setter"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、取值函数-getter-和存值函数-setter"}},[t._v("#")]),t._v(" 四、取值函数（getter）和存值函数（setter）")]),t._v(" "),v("ol",[v("li",[t._v("在“类”的内部可以使用"),v("code",[t._v("get")]),t._v("和"),v("code",[t._v("set")]),t._v("关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。")]),t._v(" "),v("li",[t._v("存值函数和取值函数是设置在属性的 Descriptor 对象上的。")])]),t._v(" "),v("h2",{attrs:{id:"五、静态方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、静态方法"}},[t._v("#")]),t._v(" 五、静态方法")]),t._v(" "),v("ol",[v("li",[t._v("类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上"),v("code",[t._v("static")]),t._v("关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。")]),t._v(" "),v("li",[t._v("如果静态方法包含"),v("code",[t._v("this")]),t._v("关键字，这个"),v("code",[t._v("this")]),t._v("指的是类，而不是实例。")]),t._v(" "),v("li",[t._v("父类的静态方法，可以被子类继承。")]),t._v(" "),v("li",[t._v("静态方法可以从"),v("code",[t._v("super")]),t._v("对象上调用的。")])]),t._v(" "),v("h2",{attrs:{id:"六、静态属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六、静态属性"}},[t._v("#")]),t._v(" 六、静态属性")]),t._v(" "),v("ol",[v("li",[t._v("静态属性指的是 Class 本身的属性，即"),v("code",[t._v("Class.propName")]),t._v("，而不是定义在实例对象（"),v("code",[t._v("this")]),t._v("）上的属性。")]),t._v(" "),v("li",[t._v("写法是在实例属性的前面，加上"),v("code",[t._v("static")]),t._v("关键字。")])]),t._v(" "),v("h2",{attrs:{id:"七、私有属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七、私有属性"}},[t._v("#")]),t._v(" 七、私有属性")]),t._v(" "),v("ol",[v("li",[t._v("在属性名之前，使用"),v("code",[t._v("#")]),t._v("表示。")]),t._v(" "),v("li",[t._v("私有属性，只能在类的内部使用。如果在类的外部使用，就会报错。")])]),t._v(" "),v("h2",{attrs:{id:"八、class-的继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#八、class-的继承"}},[t._v("#")]),t._v(" 八、Class 的继承")]),t._v(" "),v("ol",[v("li",[t._v("通过"),v("code",[t._v("extends")]),t._v("关键字实现继承。")]),t._v(" "),v("li",[t._v("子类必须在"),v("code",[t._v("constructor")]),t._v("方法中调用"),v("code",[t._v("super")]),t._v("方法，否则新建实例时会报错。")]),t._v(" "),v("li",[t._v("在子类的构造函数中，只有调用"),v("code",[t._v("super")]),t._v("之后，才可以使用"),v("code",[t._v("this")]),t._v("关键字，否则会报错。")]),t._v(" "),v("li",[t._v("父类的静态方法，也会被子类继承。")])]),t._v(" "),v("h2",{attrs:{id:"九、mixin-模式的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#九、mixin-模式的实现"}},[t._v("#")]),t._v(" 九、Mixin 模式的实现")]),t._v(" "),v("ol",[v("li",[t._v("Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。")]),t._v(" "),v("li",[t._v("将多个类的接口“混入”（mix in）另一个类。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);