(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{619:function(t,_,s){"use strict";s.r(_);var n=s(5),o=Object(n.a)({},(function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"原型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),s("h2",{attrs:{id:"_1、原型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、原型"}},[t._v("#")]),t._v(" 1、原型")]),t._v(" "),s("p",[t._v("prototype：原型，函数的一个属性，指向对象")]),t._v(" "),s("p",[t._v("__proto__：隐式原型（原型链接点），对象的一个属性，指向对象")]),t._v(" "),s("p",[t._v("关联：每个对象都有一个__proto__属性，指向创建该对象的函数的 prototype。")]),t._v(" "),s("p",[t._v("原型对象：该对象包含了可以由特定类型的所有"),s("strong",[t._v("实例")]),t._v("共享的属性和方法，原型对象的 constructor 指向构造函数本身。作用是为了创建对象时代码复用，大大减少内存消耗。")]),t._v(" "),s("ul",[s("li",[t._v("自定义函数由 Function 函数创建。")]),t._v(" "),s("li",[s("strong",[t._v("对象都是通过函数来创建的")]),t._v("。")]),t._v(" "),s("li",[s("strong",[t._v("函数也是一种对象")]),t._v("。\n"),s("ul",[s("li",[t._v("Function.__proto__===Function.prototype")]),t._v(" "),s("li",[t._v("Function.prototype.__proto__=Object.prototype")]),t._v(" "),s("li",[t._v("Object.__proto__===Function.prototype")]),t._v(" "),s("li",[t._v("Object.prototype.__proto__===null")])])])]),t._v(" "),s("img",{attrs:{src:"https://images0.cnblogs.com/blog/138012/201409/181637013624694.png"}}),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Object "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Function")]),t._v("\nFunction "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v("\nFunction "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Function")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("h2",{attrs:{id:"_2、原型链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、原型链"}},[t._v("#")]),t._v(" 2、原型链")]),t._v(" "),s("p",[t._v("每个对象（除 null）都有 "),s("code",[t._v("__proto__")]),t._v(" 属性，这个属性指向创建该对象的函数的原型。而原型对象也通过"),s("code",[t._v("__proto__")]),t._v("指向它自己的原型对象，层层向上直到 Object.prototype，这样就形成了原型链。")]),t._v(" "),s("p",[s("strong",[t._v("原型链的特点")]),t._v("：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("当访问对象属性时，如果对象内部没有这个属性，就会沿着__proto__这条原型链一直往上找。")]),t._v(" "),s("ul",[s("li",[t._v("obj.hasOwnProperty(key)：区分一个属性到底是对象内部的还是从原型中找到的。这个方法来自 Object.prototype。")]),t._v(" "),s("li",[t._v("在 for…in…循环中，key 还包括原型中的。")])])]),t._v(" "),s("li",[s("p",[t._v("当修改原型时，与之相关的对象也会继承这一改变。")])])]),t._v(" "),s("p",[s("strong",[t._v("原型链的缺点")]),t._v("：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("如果被继承的实例中包含引用类型属性，那么新生成的子类实例，如果对引用类型的属性进行修改，那么其他实例的该属性也会发生变化。")])]),t._v(" "),s("li",[s("p",[t._v("不能向超类的构造函数中添加参数。")])])])])}),[],!1,null,null,null);_.default=o.exports}}]);