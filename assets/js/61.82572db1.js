(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{622:function(o,t,v){"use strict";v.r(t);var _=v(5),e=Object(_.a)({},(function(){var o=this,t=o.$createElement,v=o._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[v("h1",{attrs:{id:"第-10-章-symbol"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第-10-章-symbol"}},[o._v("#")]),o._v(" 第 10 章_Symbol")]),o._v(" "),v("h2",{attrs:{id:"一、概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、概述"}},[o._v("#")]),o._v(" 一、概述")]),o._v(" "),v("ol",[v("li",[o._v("ES6 引入了一种新的原始数据类型"),v("code",[o._v("Symbol")])]),o._v(" "),v("li",[o._v("表示独一无二的值")]),o._v(" "),v("li",[o._v("Symbol([描述])")]),o._v(" "),v("li",[o._v("注意点\n"),v("ul",[v("li",[o._v("不能使用"),v("code",[o._v("new")]),o._v("命令")]),o._v(" "),v("li",[v("code",[o._v("Symbol")]),o._v("函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的"),v("code",[o._v("Symbol")]),o._v("函数的返回值是不相等的")]),o._v(" "),v("li",[v("code",[o._v("Symbol")]),o._v("值不能与其他类型的值进行运算")]),o._v(" "),v("li",[o._v("可以显式转为字符串、布尔值，但是不能转为数值。")])])])]),o._v(" "),v("h2",{attrs:{id:"二、定义对象的唯一属性名"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、定义对象的唯一属性名"}},[o._v("#")]),o._v(" 二、定义对象的唯一属性名")]),o._v(" "),v("ol",[v("li",[o._v("Symbol 值作为对象属性名时，不能用点运算符。")]),o._v(" "),v("li",[o._v("使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。")]),o._v(" "),v("li",[o._v("遍历对象的时候，该属性不会出现在"),v("code",[o._v("for...in")]),o._v("、"),v("code",[o._v("for...of")]),o._v("循环中，也不会被"),v("code",[o._v("Object.keys()")]),o._v("、"),v("code",[o._v("Object.getOwnPropertyNames()")]),o._v("、"),v("code",[o._v("JSON.stringify()")]),o._v("返回。"),v("code",[o._v("Object.getOwnPropertySymbols()")]),o._v("方法和"),v("code",[o._v("Reflect.ownKeys()")]),o._v("方法可返回。")])]),o._v(" "),v("h2",{attrs:{id:"三、symbol-for"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、symbol-for"}},[o._v("#")]),o._v(" 三、"),v("code",[o._v("Symbol.for()")])]),o._v(" "),v("ol",[v("li",[o._v("接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。")]),o._v(" "),v("li",[v("code",[o._v("Symbol.for()")]),o._v("与"),v("code",[o._v("Symbol()")]),o._v("这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。"),v("code",[o._v("Symbol.for()")]),o._v("不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的"),v("code",[o._v("key")]),o._v("是否已经存在，如果不存在才会新建一个值。")])]),o._v(" "),v("h2",{attrs:{id:"四、内置的-symbol-值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、内置的-symbol-值"}},[o._v("#")]),o._v(" 四、内置的 Symbol 值")]),o._v(" "),v("h3",{attrs:{id:"symbol-hasinstance"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-hasinstance"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.hasInstance")])]),o._v(" "),v("ol",[v("li",[o._v("指向一个内部方法。当其他对象使用"),v("code",[o._v("instanceof")]),o._v("运算符，判断是否为该对象的实例时，会调用这个方法。")]),o._v(" "),v("li",[o._v("可以用它自定义"),v("code",[o._v("instanceof")]),o._v(" 操作符在某个类上的行为。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-isconcatspreadable"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-isconcatspreadable"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.isConcatSpreadable")])]),o._v(" "),v("ol",[v("li",[o._v("表示该对象用于"),v("code",[o._v("Array.prototype.concat()")]),o._v("时，是否可以展开。")]),o._v(" "),v("li",[o._v("数组的默认行为是可以展开，"),v("code",[o._v("Symbol.isConcatSpreadable")]),o._v("默认等于"),v("code",[o._v("undefined")]),o._v("。该属性等于"),v("code",[o._v("true")]),o._v("时，也有展开的效果。")]),o._v(" "),v("li",[o._v("类似数组的对象正好相反，默认不展开。它的"),v("code",[o._v("Symbol.isConcatSpreadable")]),o._v("属性设为"),v("code",[o._v("true")]),o._v("，才可以展开。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-species"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-species"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.species")])]),o._v(" "),v("ol",[v("li",[o._v("指向一个构造函数。创建衍生对象时就会使用这个属性返回的函数，作为构造函数。")]),o._v(" "),v("li",[o._v("它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-match"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-match"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.match")])]),o._v(" "),v("ol",[v("li",[o._v("指向一个函数。当执行"),v("code",[o._v("str.match(myObject)")]),o._v("时，如果该属性存在，会调用它，返回该方法的返回值。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-replace"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-replace"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.replace")])]),o._v(" "),v("ol",[v("li",[o._v("指向一个方法，当该对象被"),v("code",[o._v("String.prototype.replace")]),o._v("方法调用时，会返回该方法的返回值。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-search"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-search"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.search")])]),o._v(" "),v("ol",[v("li",[o._v("指向一个方法，当该对象被"),v("code",[o._v("String.prototype.search")]),o._v("方法调用时，会返回该方法的返回值。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-split"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-split"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.split")])]),o._v(" "),v("ol",[v("li",[o._v("指向一个方法，当该对象被"),v("code",[o._v("String.prototype.split")]),o._v("方法调用时，会返回该方法的返回值。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-iterator"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-iterator"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.iterator")])]),o._v(" "),v("ol",[v("li",[o._v("指向该对象的默认遍历器方法。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-toprimitive"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-toprimitive"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.toPrimitive")])]),o._v(" "),v("ol",[v("li",[o._v("指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-tostringtag"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-tostringtag"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.toStringTag")])]),o._v(" "),v("ol",[v("li",[o._v("指向一个方法。在该对象上面调用"),v("code",[o._v("Object.prototype.toString")]),o._v("方法时，如果这个属性存在，它的返回值会出现在"),v("code",[o._v("toString")]),o._v("方法返回的字符串之中，表示对象的类型。")]),o._v(" "),v("li",[o._v("这个属性可以用来定制"),v("code",[o._v("[object Object]")]),o._v("或"),v("code",[o._v("[object Array]")]),o._v("中"),v("code",[o._v("object")]),o._v("后面的那个字符串。")])]),o._v(" "),v("h3",{attrs:{id:"symbol-unscopables"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#symbol-unscopables"}},[o._v("#")]),o._v(" "),v("code",[o._v("Symbol.unscopables")])]),o._v(" "),v("ol",[v("li",[o._v("指向一个对象。该对象指定了使用"),v("code",[o._v("with")]),o._v("关键字时，哪些属性会被"),v("code",[o._v("with")]),o._v("环境排除。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);