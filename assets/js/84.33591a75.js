(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{645:function(_,v,t){"use strict";t.r(v);var a=t(5),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"第-9-章-客户端检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-9-章-客户端检测"}},[_._v("#")]),_._v(" 第 9 章_客户端检测")]),_._v(" "),t("p",[_._v("由于浏览器间存在差别，通常需要根据不同浏览器的能力分别编写不同的代码。")]),_._v(" "),t("h2",{attrs:{id:"_1、能力检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、能力检测"}},[_._v("#")]),_._v(" 1、能力检测")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("在编写代码之前先检测特定浏览器的能力。")])]),_._v(" "),t("li",[t("p",[_._v("例如，脚本在调用某个函数之前，可能要先检测该函数是否存在。")])]),_._v(" "),t("li",[t("p",[_._v("优点：法将开发人员从考虑具体的浏览器类型和版本中解放出来，让他们把注意力集中到相应的能力是否存在上。")])]),_._v(" "),t("li",[t("p",[_._v("缺点：无法精确地检测特定的浏览器和版本。")])])]),_._v(" "),t("h4",{attrs:{id:"_1-1-更可靠的能力检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-更可靠的能力检测"}},[_._v("#")]),_._v(" 1.1 更可靠的能力检测")]),_._v(" "),t("p",[_._v("尽量使用 typeof 进行能力检测")]),_._v(" "),t("h4",{attrs:{id:"_1-2-能力检测-不是浏览器检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-能力检测-不是浏览器检测"}},[_._v("#")]),_._v(" 1.2 能力检测，不是浏览器检测")]),_._v(" "),t("p",[_._v("在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。")]),_._v(" "),t("h2",{attrs:{id:"_2、怪癖检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、怪癖检测"}},[_._v("#")]),_._v(" 2、怪癖检测")]),_._v(" "),t("ul",[t("li",[_._v("怪癖实际上是浏览器实现中存在的 bug。")]),_._v(" "),t("li",[_._v("例如早期的 WebKit 中就存在一个怪癖，即它会在 for-in 循环中返回被隐藏的属性。")]),_._v(" "),t("li",[_._v("怪癖检测通常涉及到运行一小段代码，然后确定浏览器是否存在某个怪癖。")]),_._v(" "),t("li",[_._v("缺点：与能力检测相比效率更低；无法精确地检测特定的浏览器和版本。")])]),_._v(" "),t("h2",{attrs:{id:"_3、用户代理检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、用户代理检测"}},[_._v("#")]),_._v(" 3、用户代理检测")]),_._v(" "),t("ul",[t("li",[_._v("通过检测用户代理字符串来识别浏览器。")]),_._v(" "),t("li",[_._v("用户代理字符串中包含大量与浏览器有关的信息，包括浏览器、平台、操作系统及浏览器版本。")]),_._v(" "),t("li",[_._v("用户代理检测需要特殊的技巧，特别是要注意 Opera 会隐瞒其用户代理字符串的情况。")])]),_._v(" "),t("h4",{attrs:{id:"_3-1-用户代理字符串的历史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-用户代理字符串的历史"}},[_._v("#")]),_._v(" 3.1 用户代理字符串的历史")]),_._v(" "),t("ul",[t("li",[_._v("早期的浏览器 Mozilla/版本号 [语言] (平台; 加密类型)")]),_._v(" "),t("li",[_._v("Netscape Navigator 3 和 Internet Explorer 3 Mozilla/版本号 (平台; 加密类型 [; 操作系统或 CPU 说明]) Mozilla/2.0 (compatible; MSIE 版本号; 操作系统)")]),_._v(" "),t("li",[_._v("Netscape Communicator 4 和 IE4 ～ IE8")]),_._v(" "),t("li",[_._v("Gecko")]),_._v(" "),t("li",[_._v("WebKit")]),_._v(" "),t("li",[_._v("Konqueror")]),_._v(" "),t("li",[_._v("Chrome")]),_._v(" "),t("li",[_._v("Opera")]),_._v(" "),t("li",[_._v("iOS 和 Android")])]),_._v(" "),t("h4",{attrs:{id:"_3-2-用户代理字符串检测技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-用户代理字符串检测技术"}},[_._v("#")]),_._v(" 3.2 用户代理字符串检测技术")]),_._v(" "),t("p",[_._v("一般情况下，知道"),t("strong",[_._v("呈现引擎")]),_._v("和"),t("strong",[_._v("最低限度的版本")]),_._v("就足以决定正确的操作方法了。")]),_._v(" "),t("h4",{attrs:{id:"_3-3-完整的代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-完整的代码"}},[_._v("#")]),_._v(" 3.3 完整的代码")]),_._v(" "),t("p",[_._v("完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows 操作系统、移动设备和游戏系统。")]),_._v(" "),t("h4",{attrs:{id:"_3-4-使用方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-使用方法"}},[_._v("#")]),_._v(" 3.4 使用方法")]),_._v(" "),t("p",[_._v("用户代理检测一般适用于下列情形：")]),_._v(" "),t("ul",[t("li",[_._v("不能直接准确地使用能力检测或怪癖检测。例如，某些浏览器实现了为将来功能预留的存根（stub）函数。在这种情况下，仅测试相应的函数是否存在还得不到足够的信息。")]),_._v(" "),t("li",[_._v("同一款浏览器在不同平台下具备不同的能力。这时候，可能就有必要确定浏览器位于哪个平台下。")]),_._v(" "),t("li",[_._v("为了跟踪分析等目的需要知道确切的浏览器。")])]),_._v(" "),t("h2",{attrs:{id:"_4、小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、小结"}},[_._v("#")]),_._v(" 4、小结")]),_._v(" "),t("ul",[t("li",[_._v("在决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。")]),_._v(" "),t("li",[_._v("怪癖检测是确定应该如何处理代码的第二选择。")]),_._v(" "),t("li",[_._v("而用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具有很强的依赖性。")])])])}),[],!1,null,null,null);v.default=r.exports}}]);