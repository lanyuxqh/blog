---
title: JS高程 | 第3章_基本概念
date: 2021-3-11
tags:
  - 读书笔记
  - javascript
categories:
  - 读书笔记
---

# 第 3 章\_基本概念

## 3.1 语法

### 3.1.1 区分大小写

- ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。

### 3.1.2 标识符

> **标识符**，就是指变量、函数、属性的名字，或者函数的参数。

**规则**：

- 第一个字符必须是一个字母、下划线（\_）或一个美元符号（$）；
- 其他字符可以是字母、下划线、美元符号或数字。

**其他规范**：

- _标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符，但不推荐这样做。_

- 按照惯例，ECMAScript 标识符采用驼峰大小写格式。
- 不能把关键字、保留字、true、false 和 null 用作标识符。

### 3.1.3 注释

- 单行注释：//
- 块级注释：/\* \*/ ，中间各行通常以一个星号开头，但这不是必需的。

### 3.1.4 严格模式

> **严格模式**是为 JavaScript 定义了一种不同的解析与执行模型。

**使用**：

- 要在整个脚本中启用严格模式，可以在顶部添加代码："use strict"。它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。
- 严格模式下，JavaScript 的执行结果会有很大不同。
- 支持严格模式的浏览器包括 IE10+、Firefox 4+、Safari 5.1+、Opera 12+ 和 Chrome。

### 3.1.5 语句

- ECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾。虽然分号不是必需的，但建议任何时候都不要省略它。
- 把多条语句组合到一个代码块中 {} 。

## 3.2 关键字和保留字

> **关键字**可用于表示控制语句的开始或结束，或者用于执行特定操作等。

```
break      do        instanceof     typeof
case       else      new            var
catch      finally   return         void
continue   for       switch         while
debugger*  function  this           with
default    if        throw
delete     in        try
```

> 尽管**保留字**在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。

```
abstract    enum          int          short
boolean     export        interface    static
byte        extends       long         super
char        final         native       synchronized
class       float         package      throws
const       goto          private      transient
debugger    implements    protected    volatile
double      import        public
```

## 3.3 变量

> ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。每个变量仅仅是一个用于保存值的占位符而已。

- 定义变量：var 标识符 。
- 未经过初始化的变量，会保存一个特殊的值——undefined。
- 初始化变量并不会把它标记为某种类型，初始化的过程就是给变量赋一个值。因此，可以在修改变量值的同时修改值的类型（有效但不推荐）。
- 用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。省略 var 操作符，创建的是全局变量。
- 可以使用一条语句定义多个变量。

## 3.4 数据类型

> ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：`Undefined`、`Null`、`Boolean`、`Number`和`String`。还有 1 种复杂数据类型：`Object`。

### 3.4.1 typeof 操作符

> 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。

使用 typeof 操作符可能返回下列某个字符串：

- "undefined"——如果这个值未定义；
- "boolean"——如果这个值是布尔值；
- "number"——如果这个值是数值；
- "string"——如果这个值是字符串；
- "object"——如果这个值是对象或**null**； // 因为特殊值 null 被认为是一个空的对象引用
- "function"——如果这个值是函数。

typeof 是一个操作符而不是函数。

### 3.4.2 Undefined 类型

> Undefined 类型只有一个值，即特殊的`undefined`。

- 使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。
- 对未初始化的变量执行 typeof 操作符会返回 undefined 值。

### 3.4.3 Null 类型

> Null 类型只有一个值，即特殊的`null`。

- null 值表示一个空对象指针，因此，使用 typeof 操作符检测 null 值时会返回"object"。
- undefined 值是派生自 null 值，因此，null == undefined //true
- 无论在什么情况下都没有必要把一个变量的值显式地设置为 undefined ，但是，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。

### 3.4.4 Boolean 类型

> Boolean 类型只有两个字面值：`true` 和` false`。 // 注意是小写

- 可以对任何数据类型的值调用`Boolean()`函数，返回一个 Boolean 值。

| 数据类型  | 转换为 true 的值             | 转换为 false 的值 |
| --------- | ---------------------------- | ----------------- |
| Boolean   | true                         | false             |
| String    | 任何非空字符串               | ""（空字符串）    |
| Number    | 任何非零数字值（包括无穷大） | 0 和 NaN          |
| Object    | 任何对象（包括空对象）       | null              |
| Undefined | _不适用_                     | undefined         |

- 流控制语句（如 if 语句）自动执行相应的 Boolean 转换

### 3.4.5 Number 类型

> Number 类型型使用 IEEE754 格式来表示整数和浮点数值。

- 整数
  - 十进制
    - var intNum = 55; // 整数
  - 八进制字面值的第一位必须是零（0），然后是八进制数字序列（0 ～ 7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。
    - var octalNum1 = 070; // 八进制的 56
    - var octalNum2 = 079; // 无效的八进制数值——解析为 79
  - 十六进制字面值的前两位必须是 0x，后跟任何十六进制数字（0 ～ 9 及 A ～ F 或 a-f）
    - var hexNum2 = 0x1f; // 十六进制的 31
  - 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。
- 浮点数

  - 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。
    - var floatNum3 = .1; // 有效，但不推荐
  - 由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值转换为整数值。
    - var floatNum1 = 1.; // 小数点后面没有数字——解析为 1
    - var floatNum2 = 10.0; // 整数——解析为 10
  - 对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。
    - var floatNum = 3.125e7; // 等于 31250000
  - 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。
    - 0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004，因为使用基于 IEEE754 数值的浮点计算会产生舍入误差的问题。因此，永远不要测试某个特定的浮点数值。

- 数值范围
  - 最小数值保存在`Number.MIN_VALUE`中——在大多数浏览器中，这个值是 5e-324。
  - 最大数值保存在`Number.MAX_VALUE`中——在大多数浏览器中，这个值是 1.7976931348623157e+308。
  - 如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。该值无法继续参与下一次的计算。
  - 使用`isFinite()`函数，确定一个数值是不是有穷的。
- NaN
  - 非数值（Not a Number）是一个特殊的数值，用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。
    - 例如，在其他编程语言中，任何数值除以 0 都会导致错误，从而停止代码执行。但在 ECMAScript 中，任何数值除以 0 会返回 NaN，因此不会影响其他代码的执行。
  - 特点：
    - 任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN。
    - NaN 与任何值都不相等，包括 NaN 本身。
  - `isNaN()`函数：
    - 确定这个参数是否“不是数值”，接受一个参数，该参数可以是任何类型。
    - isNaN() 在接收到一个值之后，会尝试将这个值转换为数值。
      - alert(isNaN("10")); //false（可以被转换成数值 10）
      - alert(isNaN(true)); //false（可以被转换成数值 1）
    - 在基于对象调用 isNaN() 函数时，会首先调用对象的 valueOf() 方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 toString()方法，再测试返回值。
- 数值转换
  - `Number()`函数
    - _用于任何数据类型_
    - 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。
    - 如果是数字值，只是简单的传入和返回。
    - 如果是 null 值，返回 0。
    - 如果是 undefined，返回 NaN。
    - 如果是字符串
      - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值。会忽略前导零。
      - 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值。会忽略前导零。
      - 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值；
      - 如果字符串是空的（不包含任何字符），则将其转换为 0；
      - 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。
    - 如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。
  - `parseInt()`函数
    - _专门用于把字符串转换成数值_
    - 它会忽略字符串前面的空格，直至找到第一个非空格字符。
      - 如果第一个字符不是数字字符（小数点并不是有效的数字字符）或者负号，parseInt() 就会返回 NaN。用 parseInt() 转换空字符串会返回 NaN。
      - 如果第一个字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。
    - 可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。
  - `parseFloat()`函数
    - _专门用于把字符串转换成数值_
    - 字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。
    - parseFloat() 只解析十进制值。十六进制格式的字符串则始终会被转换成 0。
    - 如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat() 会返回整数。

### 3.4.6 String 类型

> String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。可用单引号或双引号表示。

- 字符字面量

  - String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。

    | 字面量 | 含义                                                                                         |
    | ------ | -------------------------------------------------------------------------------------------- |
    | \n     | 换行                                                                                         |
    | \t     | 制表                                                                                         |
    | \b     | 空格                                                                                         |
    | \r     | 回车                                                                                         |
    | \f     | 进纸                                                                                         |
    | \\     | 斜杠                                                                                         |
    | \'     | 单引号（'）                                                                                  |
    | \"     | 双引号（"）                                                                                  |
    | \xnn   | 以十六进制代码 nn 表示的一个字符（其中 n 为 0 ～ F）。例如，\x41 表示"A"                     |
    | \unnnn | 以十六进制代码 nnnn 表示的一个 Unicode 字符（其中 n 为 0 ～ F）。例如，\u03a3 表示希腊字符 Σ |

    - 这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析

- 字符串的特点

  - ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。

- 转换为字符串

  - `toString()`方法
    - 返回相应值的字符串表现。
    - 数值、布尔值、对象和字符串值都有 toString()方法。但 null 和 undefined 值没有这个方法。
    - 可以传递一个参数：输出数值的基数。
  - `String()`函数
    - 能够将任何类型的值转换为字符串。
    - 如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果；
    - 如果值是 null，则返回"null"；
    - 如果值是 undefined，则返回"undefined"。
  - 要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（""）加在一起。

### 3.4.7 Object 类型

> ECMAScript 中的对象其实就是一组数据和功能的集合。

- 对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。

- Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。
  - constructor：保存着用于创建当前对象的函数。
  - hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。
  - isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。
  - propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句。
  - toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
  - toString()：返回对象的字符串表示。
  - valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。

## 3.5 操作符

> ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。

### 3.5.1 一元操作符

> 只能操作一个值的操作符叫做一元操作符。

- 递增（++）和递减操作符（--），分为前置型和后置型。
- 一元加（+）和减（-）操作符

### 3.5.2 位操作符

> 位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。

- 按位非（NOT）（~） // 返回数值的反码
- 按位与（AND）（&） // 只在两个数值的对应位都是 1 时才返回 1
- 按位或（OR） （|） // 有一个位是 1 的情况下就返回 1
- 按位异或（XOR） （^） // 两个数值对应位上只有一个 1 时才返回 1
- 左移 （ << ）
  - 以 0 来填充空位。
  - 左移不会影响操作数的符号位。换句话说，如果将 -2 向左移动 5 位，结果将是 -64，而非 64。
- 有符号的右移 （>>）
  - 用符号位的值来填充所有空位。
- 无符号右移 （>>>）
  - 以 0 来填充空位。
  - 无符号右移操作符会把负数的二进制码当成正数的二进制码。

### 3.5.3 布尔操作符

- 逻辑非 （！）
  - 首先会将它的操作数转换为一个布尔值，然后再对其求反。
  - 同时使用两个逻辑非操作符，实际上就会模拟 Boolean() 转型函数的行为。
- 逻辑与 （&&）
  - 属于**短路操作**，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。
- 逻辑或 （||）
  - 属于**短路操作**

### 3.5.4 乘性操作符

- 乘法 （\*）
  - 如果操作数都是数值，执行常规的乘法计算。
  - 如果有一个操作数是 NaN，则结果是 NaN。
  - 如果是 Infinity 与 0 相乘，则结果是 NaN。
  - 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号；
  - 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity。
  - 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。
- 除法 （/）
  - 如果操作数都是数值，执行常规的除法计算。
  - 如果有一个操作数是 NaN，则结果是 NaN。
  - 如果是 Infinity 被 Infinity 除，则结果是 NaN。
  - 如果是零被零除，则结果是 NaN。
  - 如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号。
  - 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号。
  - 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。
- 求模 （%）
  - 如果操作数都是数值，执行常规的除法计算，返回除得的余数。
  - 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN。
  - 如果被除数是有限大的数值而除数是零，则结果是 NaN。
  - 如果是 Infinity 被 Infinity 除，则结果是 NaN。
  - 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数。
  - 如果被除数是零，则结果是零。
  - 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。

### 3.5.5 加性操作符

- 加法 （+）

  - 如果两个操作符都是数值，执行常规的加法计算。
    - 如果有一个操作数是 NaN，则结果是 NaN
    - 如果是 Infinity 加 Infinity，则结果是 Infinity
    - 如果是 -Infinity 加 -Infinity，则结果是 -Infinity
    - 如果是 Infinity 加 -Infinity，则结果是 NaN
    - 如果是 +0 加 +0，则结果是 +0
    - 如果是 -0 加 -0，则结果是 -0
    - 如果是 +0 加 -0，则结果是 +0
  - 如果有一个操作数是字符串。

    - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来
    - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来

  - 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。
  - 对于 undefined 和 null，则分别调用 String() 函数并取得字符串"undefined"和"null"。

- 减法 （-）

  - 如果两个操作符都是数值，则执行常规的算术减法操作。
    - 如果有一个操作数是 NaN，则结果是 NaN
    - 如果是 Infinity 减 Infinity，则结果是 NaN
    - 如果是 -Infinity 减 -Infinity，则结果是 NaN
    - 如果是 Infinity 减 -Infinity，则结果是 Infinity
    - 如果是 -Infinity 减 Infinity，则结果是 -Infinity
    - 如果是 +0 减 +0，则结果是 +0
    - 如果是 +0 减 -0，则结果是 -0
    - 如果是 -0 减 -0，则结果是 +0
  - 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN。
  - 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf() 方法，则调用其 toString() 方法并将得到的字符串转换为数值。

### 3.5.6 关系操作符

- 小于（<）
- 大于（>）
- 小于等于（<=）
- 大于等于（>=）
  - 如果两个操作数都是数值，则执行数值比较。
    - 任何操作数与 NaN 进行关系比较，结果都是 false
  - 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
  - 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
  - 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。
  - 如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。

### 3.5.7 相等操作符

- 相等（==）和不相等（!=）
  - 先转换
    - 如果有一个操作数是布尔值，则先将其转换为数值
    - 如果一个操作数是字符串，另一个操作数是数值，先将字符串转换为数值
    - 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较
    - 不能将 null 和 undefined 转换成其他任何值。
  - 再比较
    - null 和 undefined 是相等的
    - 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true
    - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true
- 全等（===）和不全等（!==）
  - 仅比较而不转换
  - null === undefined 会返回 false，因为它们是不同类型的值。

### 3.5.8 条件操作符

- （xxx ? a : b）

### 3.5.9 赋值操作符

- 简单的赋值操作符（=）
- 复合赋值操作符
  - 乘/赋值（\*=）
  - 除/赋值（/=）；
  - 模/赋值（%=）；
  - 加/赋值（+=）；
  - 减/赋值（-=）；
  - 左移/赋值（<<=）；
  - 有符号右移/赋值（>>=）；
  - 无符号右移/赋值（>>>=）。

### 3.5.10 逗号操作符

- 使用逗号操作符（,）可以在一条语句中执行多个操作。

## 3.6 语句

> ECMA-262 规定了一组语句（也称为流控制语句）

### 3.6.1 if 语句

- if (condition) statement1 else statement2
- 其中的 condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript 会自动调用 Boolean() 转换函数将这个表达式的结果转换为一个布尔值。

### 3.6.2 do-while 语句

- do {
  statement
  } while (expression);
- 在对条件表达式求值之前，循环体内的代码至少会被执行一次。

### 3.6.3 while 语句

- while(expression) statement

### 3.6.4 for 语句

- for (initialization; expression; post-loop-expression) statement
- for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。

### 3.6.5 for-in 语句

- for (property in expression) statement
- 是一种精准的迭代语句，可以用来枚举对象的属性。
- 当要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。ECMAScript 5 更正了这一行为，对这种情况不再抛出错误，而只是不执行循环体。

### 3.6.6 label 语句

- label: statement

### 3.6.7 break 和 continue 语句

- break 语句会立即退出循环，强制继续执行循环后面的语句。
- continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。
- break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。

### 3.6.8 with 语句

- with (expression) statement
- with 语句的作用是将代码的作用域设置到一个特定的对象中。目的是为了简化多次编写同一个对象的工作。
- 严格模式下不允许使用 with 语句，否则将视为语法错误。
- 由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。

### 3.6.9 switch 语句

- switch (expression) {
  case value: statement
  break;
  case value: statement
  break;
  case value: statement
  break;
  case value: statement
  break;

  default: statement
  }

- 如果省略 break 关键字，就会导致执行完当前 case 后，继续执行下一个 case。

- 可以在 switch 语句中使用任何数据类型。

- 每个 case 的值不一定是常量，可以是变量，甚至是表达式。

- switch 语句在比较值时使用的是全等操作符。

## 3.7 函数

- function functionName(arg0, arg1,...,argN) {
  statements
  }
- 无须指定函数的返回值，因为任何 ECMAScript 函数都可以在任何时候返回任何值。
- 未指定返回值的函数返回的是一个特殊的 undefined 值。

### 3.7.1 理解参数

- ECMAScript 中的参数在内部是用一个数组来表示，在函数体内可以通过`arguments`对象来访问这个参数数组，从而获取传递给函数的每一个参数。
- arguments 对象只是与数组类似（它并不是 Array 的实例）
  - 可以使用方括号语法访问它的每一个元素。
  - 通过访问 arguments 对象的 length 属性可以获知有多少个参数传递给了函数。
  - arguments 对象可以与命名参数一起使用。
  - 它的值永远与对应命名参数的值保持同步。
- 没有传递值的命名参数将自动被赋予 undefined 值。
- ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。

### 3.7.2 没有重载

- 如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。
- 通过检查传入函数中参数的类型和数量并作出不同的反应，可以**模仿**方法的重载。
