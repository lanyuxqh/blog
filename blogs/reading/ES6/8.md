---
title: ES6标准入门 | 第8章_数组的扩展
date: 2021-8-31
tags:
  - 读书笔记
  - javascript
categories:
  - 读书笔记
---

# 第 8 章\_数组的扩展

## 一、扩展运算符

1. 含义：扩展运算符（spread）是三个点（`...`），将一个数组转为用逗号分隔的参数序列。
2. 由于扩展运算符可以展开数组，所以不再需要`apply`方法，将数组转为函数的参数了。
3. 应用
   - 复制数组
   - 合并数组
   - 与解构赋值结合，生成数组
   - 函数的返回值
   - 字符串
   - 实现了 Iterator 接口的对象
   - Map 和 Set 结构，Generator 函数

## 二、Array.from

1. 将两类对象转为真正的数组**：类似数组的对象（array-like object，有 length 属性）**和**可遍历（iterable）的对象**（包括 ES6 新增的数据结构 Set 和 Map）。
2. 第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
3. 第三个参数，用来绑定`this`。（如果`map`函数里面用到了`this`关键字）
4. 另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于`\uFFFF`的 Unicode 字符，算作两个字符的 bug。
5. 与扩展运算符的区别
   - `...`背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。
   - `Array.from`方法还支持类似数组的对象。
6. 对于还没有部署该方法的浏览器，可以用`Array.prototype.slice`方法替代。`[].slice.call(obj)`

## 三、Array.of()

1. 将一组值，转换为数组。弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。
2. 返回参数值组成的数组。如果没有参数，就返回一个空数组。

## 四、数组实例的方法

### `copyWithin()`

- 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，修改当前数组。
- 三个参数：
  - target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
  - start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
  - end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

### `find()`

- 返回第一个符合条件的数组成员。

- 第一个参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。

- 可以接受第二个参数，用来绑定回调函数的`this`对象。

- 回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。

- 可以发现`NaN`，弥补了数组的`indexOf`方法的不足。

  ```javascript
  ;[NaN].indexOf(NaN)
  // -1
  ```

### `findIndex()`

- 返回第一个符合条件的数组成员的位置。

- 第一个参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员的位置。如果没有符合条件的成员，则返回`-1`。

- 可以接受第二个参数，用来绑定回调函数的`this`对象。

- 回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。

- 可以发现`NaN`，弥补了数组的`indexOf`方法的不足。

  ```javascript
  ;[NaN].findIndex(y => Object.is(NaN, y))
  // 0
  ```

### `fill()`

- 使用给定值，填充一个数组。

- 第一个参数给定值。

- 可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。

- 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。

  ```javascript
  let arr = new Array(3).fill({ name: 'Mike' })
  arr[0].name = 'Ben'
  arr
  // [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]

  let arr = new Array(3).fill([])
  arr[0].push(5)
  arr
  // [[5], [5], [5]]
  ```

### `entries()`，`keys()`和`values()`

- 用于遍历数组，都返回一个遍历器对象，可以用`for...of`循环进行遍历。
- `keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。

### `includes()`

- 返回一个布尔值，表示某个数组是否包含给定的值。

- 第一个参数给定值。

- 可以接受第二个参数，表示搜索的起始位置，默认为`0`。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为`-4`，但数组长度为`3`），则会重置为从`0`开始。

- `indexOf`方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于`-1`，表达起来不够直观。二是，它内部使用严格相等运算符（`===`）进行判断，这会导致对`NaN`的误判。

  ```javascript
  ;[NaN]
    .indexOf(NaN)
    // -1

    [NaN].includes(NaN)
  // true
  ```

### `flat()`

- 将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。
- 参数写成一个整数，表示想要拉平的层数，默认为 1。Infinity 表示不管有多少层嵌套，都要转成一维数组。
- 如果原数组有空位，`flat()`方法会跳过空位。

### `flatMap()`

- 对原数组的每个成员执行一个函数（相当于执行`map()`），然后对返回值组成的数组执行`flat()`方法，只能展开一层数组。。
- 第一个参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。
- 可以有第二个参数，用来绑定遍历函数里面的`this`。

## 五、数组的空位

1. 数组的空位指，数组的某一个位置没有任何值。

2. 空位不是`undefined`，一个位置的值等于`undefined`，依然是有值的。

   ```javascript
   0 in [undefined, undefined, undefined] // true
   0 in [, , ,] // false
   ```

3. ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。
   - `forEach()`, `filter()`, `reduce()`, `every()` 和`some()`都会跳过空位。
   - `map()`会跳过空位，但会保留这个值
   - `join()`和`toString()`会将空位视为`undefined`，而`undefined`和`null`会被处理成空字符串。
4. ES6 则是明确将空位转为`undefined`。
   - `Array.from`方法会将数组的空位，转为`undefined`，也就是说，这个方法不会忽略空位。
   - 扩展运算符（`...`）也会将空位转为`undefined`。
   - `copyWithin()`会连空位一起拷贝。
   - `fill()`会将空位视为正常的数组位置。
   - `for...of`循环也会遍历空位。
   - `entries()`、`keys()`、`values()`、`find()`和`findIndex()`会将空位处理成`undefined`。
5. 由于空位的处理规则非常不统一，所以建议避免出现空位。

## 六、Array.prototype.sort()

1. 排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。
2. 常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。
3. 早先的 ECMAScript 没有规定，`Array.prototype.sort()`的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。
4. ES2019 明确规定，`Array.prototype.sort()`的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。
