---
title: ES6标准入门 | 第9章_对象的扩展
date: 2021-9-1
tags:
  - 读书笔记
  - javascript
categories:
  - 读书笔记
---

# 第 9 章\_对象的扩展

## 一、属性简洁表达

1. ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。
2. 这种写法用于函数的返回值、CommonJS 模块输出一组变量、打印对象，将会非常方便。
3. _注意，简写的对象方法不能用作构造函数，会报错。_

## 二、属性名表达式

1. ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。
2. 表达式还可以用于定义方法名。
3. _注意，属性名表达式与简洁表示法，不能同时使用，会报错。_
4. 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串`[object Object]`

## 三、方法的 name 属性

1. 对象方法也是函数，也有`name`属性。方法的`name`属性返回函数名（即方法名）。
2. 如果对象的方法使用了取值函数（`getter`）和存值函数（`setter`），则`name`属性不是在该方法上面，而是该方法的属性的描述对象的`get`和`set`属性上面，返回值是方法名前加上`get`和`set`。
3. `bind`方法创造的函数，`name`属性返回`bound`加上原函数的名字；`Function`构造函数创造的函数，`name`属性返回`anonymous`。
4. 如果对象的方法是一个 Symbol 值，那么`name`属性返回的是这个 Symbol 值的描述。

## 四、属性的可枚举性

1. `Object.getOwnPropertyDescriptor`方法可以获取对象某属性的描述对象。
2. 描述对象的`enumerable`属性，称为“可枚举性”，如果该属性为`false`，就表示某些操作会忽略当前属性。

   - `for...in`循环：只遍历对象自身的和**继承**的可枚举的属性。
   - `Object.keys()`：返回对象自身的所有可枚举的属性的键名。
   - `JSON.stringify()`：只串行化对象自身的可枚举的属性。
   - `Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。

3. 引入“可枚举”（`enumerable`）这个概念的最初目的，就是让某些属性可以规避掉`for...in`操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的`toString`方法，以及数组的`length`属性，就通过“可枚举性”，从而避免被`for...in`遍历到。
4. 所有 Class 的原型的方法都是不可枚举的。
5. 操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用`for...in`循环，而用`Object.keys()`代替。

## 五、属性的遍历

1. ES6 一共有 5 种方法可以遍历对象的属性。

   - **for...in**：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。
   - **Object.keys(obj)**：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
   - **Object.getOwnPropertyNames(obj)**：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
   - **Object.getOwnPropertySymbols(obj)**：返回一个数组，包含对象自身的所有 Symbol 属性的键名。
   - **Reflect.ownKeys(obj)**：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

2. 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。
   - 首先遍历所有数值键，按照数值升序排列。
   - 其次遍历所有字符串键，按照加入时间升序排列。
   - 最后遍历所有 Symbol 键，按照加入时间升序排列。

## 六、super 关键字

1. 关键字`super`，指向当前对象的原型对象。
2. *注意，`super`关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。*目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。

## 七、对象的扩展运算符

1. 对象的**解构赋值**用于从一个对象取值，相当于将目标对象自身的所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。
   - 如果等号右边是`undefined`或`null`，就会报错，因为它们无法转为对象。
   - 解构赋值必须是最后一个参数，否则会报错。
   - 解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。
   - 不能复制继承自原型对象的属性。
   - 解构赋值的另一个用处，是扩展某个函数的参数，引入其他操作。
2. 对象的扩展运算符用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
   - 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。
   - 如果扩展运算符后面是一个空对象，则没有任何效果。
   - 如果扩展运算符后面不是对象，则会自动将其转为对象。
   - 如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。
   - 对象的扩展运算符等同于使用`Object.assign()`方法。
3. 其他用处
   - 扩展运算符可以用于合并两个对象。
   - 修改现有对象部分的属性。
   - 设置新对象的默认属性值。
4. 对象的扩展运算符后面可以跟表达式。
5. 扩展运算符的参数对象之中，如果有取值函数`get`，这个函数是会执行的。

## 八、对象新增的方法

### `Object.is()`

- ES5 比较两个值是否相等：相等运算符（`==`）会自动转换数据类型；严格相等运算符（`===`）的`NaN`不等于自身，+0`等于`-0。

- `Object.is`，用来比较两个值是否严格相等。

  ```javascript
  ;+0 === -0 //true
  NaN === NaN // false

  Object.is(+0, -0) // false
  Object.is(NaN, NaN) // true
  ```

### `Object.assign()`

- 用于对象的合并，将源对象（source）的所有**可枚举属性**，复制到目标对象（target）。
- 第一个参数是目标对象，后面的参数都是源对象。
  - 如果只有一个参数，会直接返回该参数。如果该参数不是对象，则会先转成对象，然后返回。_由于`undefined`和`null`无法转成对象，所以如果它们作为参数，就会报错。_
  - 如果非对象参数出现在源对象的位置（即非首参数），首先，这些参数都会转成对象，如果无法转成对象，就会跳过。
    - 如果`undefined`和`null`不在首参数，就不会报错。
    - 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。因为布尔值、数值、字符串分别转成对应的包装对象，它们的原始值都在包装对象的内部属性`[[PrimitiveValue]]`上面，这个属性不会被拷贝。
    - 字符串会以数组形式，拷贝入目标对象。因为只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。
- 注意点：
  - 只拷贝源对象的自身属性、属性名为 Symbol 值的属性，不拷贝继承属性、不可枚举的属性。
  - 实行的是浅拷贝（只复制一层），而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
  - 同名属性是直接替换。
  - 可以用来处理数组，但是会把数组视为对象。
  - 只能进行值的复制，如果要复制的值是一个**取值函数**，那么将求值后再复制。
- 用途
  - 为对象添加属性
  - 为对象添加方法
  - 克隆对象
  - 合并多个对象
  - 为属性指定默认值

### `Object.getOwnPropertyDescriptors()`

- 返回指定对象所有自身属性（非继承属性）的描述对象。
- 该方法的引入目的，主要是为了解决`Object.assign()`无法正确拷贝`get`属性和`set`属性的问题。`Object.getOwnPropertyDescriptors()`方法配合`Object.defineProperties()`方法，就可以实现正确拷贝。

```javascript
// Object.assign()
const source = {
  set foo(value) {
    console.log(value)
  }
}

const target1 = {}
Object.assign(target1, source)

Object.getOwnPropertyDescriptor(target1, 'foo')
// { value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true }

// Object.getOwnPropertyDescriptors()
const source = {
  set foo(value) {
    console.log(value)
  }
}

const target2 = {}
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source))
Object.getOwnPropertyDescriptor(target2, 'foo')
// { get: undefined,
//   set: [Function: set foo],
//   enumerable: true,
//   configurable: true }
```

- 其他用处：
  - 是配合`Object.create()`方法，将对象属性克隆到一个新对象。这属于浅拷贝。
  - 可以实现一个对象继承另一个对象。
  - 可以实现 Mixin（混入）模式。

### `__proto__`属性

- 用来读取或设置当前对象的原型对象（prototype）。
- 它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性。

### `Object.setPrototypeOf()`

- 用来设置一个对象的原型对象，返回参数对象本身。`Object.setPrototypeOf(object, prototype)`
- 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。
- _由于`undefined`和`null`无法转为对象，所以如果第一个参数是`undefined`或`null`，就会报错。_

### `Object.getPrototypeOf()`

- 用于读取一个对象的原型对象。`Object.getPrototypeOf(obj)`
- 如果参数不是对象，会被自动转为对象。
- _如果参数是`undefined`或`null`，它们无法转为对象，所以会报错。_

### `Object.keys()`，`Object.values()`，`Object.entries()`

- `Object.keys`方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
- `Object.values`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
  - 会过滤属性名为 Symbol 值的属性。
  - 如果参数不是对象，`Object.values`会先将其转为对象
  - 如果参数是一个字符串，会返回各个字符组成的一个数组。
- `Object.entries()`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
  - 基本用途是遍历对象的属性。
  - 另一个用处是，将对象转为真正的`Map`结构。

### `Object.fromEntries()`

- `Object.entries()`的逆操作，用于将一个键值对数组**转为对象**。
- 特别适合将 Map 结构转为对象。
- 配合`URLSearchParams`对象，将查询字符串转为对象。

## 九、Null 传导运算符

- `?.` 替代层层判断
- 只要有一个返回`null`或`undefined`，就不再继续运算，而是返回`undefined`。
