---
title: 你不知道的JS | 第一部分_作用域和闭包
date: 2021-7-5
tags:
  - 读书笔记
  - javascript
categories:
  - 读书笔记
---

# 第一部分\_作用域和闭包

## 第 1 章\_作用域是什么

> **作用域**是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

### 1.1 　编译原理

传统编译语言的“编译”过程：

- 分词/词法分析（Tokenizing/Lexing）：将字符串分解成有意义的代码块。
- 解析/语法分析（Parsing）：将词法单元流（数组）转化为抽象语法树（AST）。
- 代码生成：将 AST 转换为可执行代码的过程称被称为代码生成。

JS 不同：

- 不是提前编译的，编译结果也不能在分布式系统中进行移植。

- JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

### 1.2 　理解作用域

引擎：从头到尾负责整个 JavaScript 程序的编译及执行过程。

编译器：负责语法分析及代码生成等脏活累活。

作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

```javascript
var a = 2
```

编译器：

- 将这段程序分解成词法单元。
- 将词法单元解析成一个树结构。
- 代码生成：首先编译器会要求作用域在当前作用域的集合中声明一个新的变量（如果之前没有声明过），然后为引擎生成运行时所需的代码。

引擎：

- 引擎执行代码时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助。
- LHS：赋值 RHS：查找值

作用域

- 回应引擎的查找

### 1.3 　作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。

遍历嵌套作用域链的规则：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

### 1.4 　异常

在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，LHS 和 RHS 两种查询的行为是不一样的。

- LHS：当引擎执 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。
- RHS：如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛`ReferenceError`异常。如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，引擎会抛出`TypeError`异常。

---

## 第 2 章\_词法作用域

### 2.1 　词法阶段

词法作用域就是定义在词法阶段的作用域。词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

### 2.2 　欺骗词法

- eval(..) 函数：函数接受一个字符串为参数，对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。
- with 声明：通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

- 副作用：引擎无法在编译时对作用域查找进行优化。如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，可能完全不做任何优化。

---

## 第 3 章\_函数作用域和块作用域

### 3.1 　函数中的作用域

函数作用域：属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。---能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。

### 3.2 　隐藏内部实现

把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。

“隐藏”的好处：符合良好软件的设计原则；可以避免同名标识符之间的冲突。

### 3.3 　函数作用域

区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

- 匿名函数表达式
  - 缺点：没有函数名，调试困难，代码可读性差；当需要引用自身时只能使用已经过期的 arguments.callee 引用。
- 立即执行函数表达式

### 3.4 　块作用域

块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{ .. } 内部）。

- with
- try/catch
- let
- const

---

## 第 4 章\_提升

### 4.1 　先有鸡还是先有蛋

到底是声明（蛋）在前，还是赋值（鸡）在前？

```javascript
// 例子一
a = 2
var a
console.log(a) // 2

// 例子二
console.log(a) // undefined
var a = 2
```

### 4.2 　编译器再度来袭

定义声明是在编译阶段进行的。赋值声明会被留在原地等待执行阶段。先有蛋（声明）后有鸡（赋值）。

所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。

声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。

```javascript
foo()
function foo() {
  console.log(a) // undefined
  var a = 2
}

foo() // 不是ReferenceError, 而是TypeError!
var foo = function bar() {
  // ...
}

foo() // TypeError
bar() // ReferenceError
var foo = function bar() {
  // ...
}
```

### 4.3 　函数优先

函数声明会被提升到普通变量之前。

```javascript
foo() // 1
var foo
function foo() {
  console.log(1)
}
foo = function () {
  console.log(2)
}

// 相当于
function foo() {
  console.log(1)
}
foo() // 1
foo = function () {
  console.log(2)
}
```

出现在后面的函数声明还是可以覆盖前面的。因此，要注意避免重复声明。

```javascript
foo() // 3
function foo() {
  console.log(1)
}
var foo = function () {
  console.log(2)
}
function foo() {
  console.log(3)
}
```

一个普通块内部的函数声明通常会被提升到所在作用域的顶部。

```javascript
foo() // "b"
var a = true
if (a) {
  function foo() {
    console.log('a')
  }
} else {
  function foo() {
    console.log('b')
  }
}
```

---

## 第 5 章\_作用域闭包

> 闭包使一个函数可以继续访问它定义时的作用域。

### 5.1 　启示

闭包是基于词法作用域书写代码时所产生的自然结果。

JavaScript 中闭包无处不在，你只需要能够识别并拥抱它。

### 5.2 　实质问题

当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。

```javascript
function foo() {
  var a = 2
  function bar() {
    console.log(a)
  }
  return bar
}
var baz = foo()
baz() // 2——这就是闭包的效果。
```

在 foo() 执行后，拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。

bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。

因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar），不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。

bar() 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。

### 5.3 　现在我懂了

在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

### 5.4 　循环和闭包

```javascript
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}

for (var i = 1; i <= 5; i++) {
  ;(function (j) {
    setTimeout(function timer() {
      console.log(j)
    }, j * 1000)
  })(i)
}

for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

### 5.5 　模块

```javascript
function CoolModule() {
  var something = 'cool'
  var another = [1, 2, 3]
  function doSomething() {
    console.log(something)
  }
  function doAnother() {
    console.log(another.join(' ! '))
  }
  return {
    doSomething: doSomething,
    doAnother: doAnother
  }
}
var foo = CoolModule()
foo.doSomething() // cool
foo.doAnother() // 1 ! 2 ! 3
```

模块有两个主要特征：

（1）为创建内部作用域而调用了一个包装函数；

（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

---

## 附录 A\_动态作用域

动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。

this 机制某种程度上很像动态作用域。

主要区别：

- 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this 也是！）

- 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。

---

## 附录 B\_块作用域的替代方案

---

## 附录 C_this 词法
