---
title: 垃圾回收与内存泄露
date: 2022-5-29
tags:
  - javascript
categories:
  - javascript
---

# 垃圾回收与内存泄露

## 1、垃圾回收

找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔周期性地执行这一操作。

JavaScript 是一门具有自动垃圾收集机制的编程语言，因此开发人员不必关心内存分配和回收问题。

JS 环境中分配的内存一般有如下生命周期：

1. 内存分配：当我们申明变量、函数、对象，并执行的时候，系统会自动为他们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

### 1.1 标记清除算法

JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

该算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将**定期从根开始**扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

- **标记阶段**，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。

- **清除阶段**，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。

**缺点**：

- 那些无法从根对象查询到的对象都将被清除
- 垃圾收集后有可能会造成大量的内存碎片

### 1.2 引用计数算法

最初级的垃圾收集算法。现在已经没有浏览器会用这种算法。这个算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。

引用计数就是记录每个变量被引用的次数，如果次数为 0，就回收变量。

**缺点**：

- 无法处理循环引用。如果两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

### 1.3 Chrome V8 垃圾回收算法

Chrome 浏览器的 V8 引擎采用的是分代回收策略。在 V8 中，将内存分为新生代和老生代，**新生代内存 存储的为存活时间较短的对象**，**老生代内存 存储的为存活时间较长或常驻内存的对象**。然后分别对不同分代的内存施以更高效的算法。

目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（**新生代**），少回收「持久对象区」（**老生代**），减少每次需遍历的对象，从而减少每次垃圾回收的耗时。

**新生代算法**：

- Scavenge 算法。是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态**。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间**。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而(From 空间内的)非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换(**即以前的 From 空间释放后变为 To;To 空间在复制存活的对象后,变为 From 空间**)。简而言之，在垃圾回收过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。
- 优点：由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它**在时间效率上有优异的表现**。
- 缺点：只能使用堆内存中的一半

**晋升**：

- 当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理**。对象从新生代中移动到老生代中的过程称为晋升**。
- 晋升的条件主要有两个：一个是对象是否经历过 Scavenge 回收，一个是 To 空间的内存占用比超过 25%限制。

**老生代算法**：

- 标记清除算法**。在标记阶段遍历堆中所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象**。
- 缺点：在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现**需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的**。
- 解决：标记整理。对象在标记为死亡后，**在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存**。

**增量式标记回收**：

- “全停顿”**：垃圾回收需要将应用逻辑暂停下来**，待执行完垃圾回收后再恢复执行应用逻辑。V8 的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。
- 为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是**拆分为许多小“步进”，每做完一“步进”就让 js 应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成**。

### 1.4 垃圾回收算法比较

**Mark-Sweep、Mark-Compact、Scavenge 三种主要垃圾回收算法的简单对比**

| 回收算法     | Mark-Sweep   | Mark-Compact | Scavenge           |
| ------------ | ------------ | ------------ | ------------------ |
| 速度         | 中等         | 最慢         | 最快               |
| 空间开销     | 少（有碎片） | 少（无碎片） | 双倍空间（无碎片） |
| 是否移动对象 | 否           | 是           | 是                 |

## 2、内存泄露

当一块内存不再用到，但是垃圾回收机制又无法释放这块内存的时候，就导致内存泄漏。减少了可用内存数量从而降低计算机性能，严重的可能导致设备停止正常工作，或者应用程序崩溃。

### 2.1 内存泄露的原因

- 意外的全局变量

```js
function foo() {
  bar = 2 // bar没被声明，会变成一个全局变量，在页面关闭之前不会被释放，使用严格模式可以避免
  console.log('bar没有被声明!')
}
```

- dom 清空时，还存在引用

```js
var element = {
  shotCat: document.getElementById('shotCat')
}

document.body.removeChild(document.getElementById('shotCat'))
// 如果element没有被回收，这里移除了 shotCat 节点也是没用的，shotCat 节点依然留存在内存中.
```

与此类似情景还有：DOM 节点绑定了事件，但是在移除的时候没有解除事件绑定，那么仅仅移除 DOM 节点也是没用的。

- 定时器没有清除

```js
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
// 如果没有清除定时器，那么 someResource 就不会被释放，如果刚好它又占用了较大内存，就会引发性能问题.
```

但是 **setTimeout ，它计时结束后它的回调里面引用的对象占用的内存是可以被回收的**。 当然有些场景 setTimeout 的计时可能很长,，这样的情况下也是需要纳入考虑的。

- 不规范地使用闭包

```js
function foo() {
  var a = {}
  function bar() {
    console.log(a)
  }
  a.fn = bar
  return bar
}
// bar和a形成了相互循环引用
```

可能有人说 bar 里不使用 console.log(a)不就没有引用了吗就不会造成内存泄露了。NONONO，**bar 作为一个闭包，即使它内部什么都没有，foo 中的所有变量都还是隐式地被 bar 所引用**。 **即使 bar 内什么都没有还是造成了循环引用**。解决办法就是，不要将 a.fn = bar。

### 2.2 避免策略

- 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收(**即赋值为 null**)；
- 注意程序逻辑，避免“死循环”之类的 ；
- 避免创建过多的对象原则**：不用了的东西要记得及时归还**。
- 减少层级过多的引用

### 2.3 检测和处理

**检测**：Chrome 的开发者工具 timeline 检测内存占用或 profiles 来进行快照对比。Node 提供的`process.memoryUsage()`方法来检查内存泄露。

**处理**：及时对无用的数据进行垃圾回收。减少使用不必要的全局变量或生命周期较长的变量。变量导致的内存泄露，将变量清除 a = null 即可。事件监听导致的内存泄露，监听后移除即可。
