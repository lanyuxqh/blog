---
title: 函数
date: 2021-12-28
tags:
  - javascript
categories:
  - javascript
---

# 函数

**定义函数的方法**

1）函数声明：具有函数声明提升特征（可以把函数声明放在调用它的语句后面）

2）函数表达式：可以使用匿名函数（拉姆达函数）；可以通过条件判断定义函数表达式的不同逻辑

## 1、call、apply、bind

`call()`和`apply()`都是在特定的作用域中调用函数，**用于扩充函数赖以运行的作用域**。区别仅在于传入参数的形式的不同。

- `call()` 第一个参数是对象，其余参数必须逐个列举出来；
- `apply()` 第一个参数是对象，第二个参数是参数数组；
- `bind()` 第一个参数是对象，其余参数必须逐个列举出来，返回这个对象绑定的新函数。

**call 方法比 apply 快的原因**：call 方法的参数格式正是内部方法所需要的格式。

**函数 bind 两次后 this 指向**：在第一次 bind 完 this 就已经确定了，结果返回一个函数，这个函数体内不存在 this 问题，后续无论 bind 多少次，this 都指向第一次 bind 传入的 context，但是后面 bind 再传入的参数会失效。（类似柯里化过程）

**call 实现**

```js
Function.prototype.myCall = function (obj) {
  obj = obj || window // 取绑定this
  obj.fn = this // 取原函数
  let args = [...arguments].slice(1) // 取传递的参数
  let res
  if (args.length >= 1) {
    res = obj.fn(...args)
  } else {
    res = obj.fn()
  }
  delete obj.fn
  return res
}
```

**apply 实现**

```js
Function.prototype.myApply = function (obj) {
  obj = obj || window
  obj.fn = this
  let args = arguments[1]
  let res
  if (args) {
    res = obj.fn(...args)
  } else {
    res = obj.fn()
  }
  delete obj.fn
  return res
}
```

**bind 实现**

```js
Function.prototype.myBind = function (obj) {
  obj = obj || window
  fn = this
  let args = [...arguments].slice(1)
  return function () {
    return fn.call(obj, ...args, ...arguments)
  }
}
```

**call 和 apply 其他用途**：借用其他对象的方法

## 2、js 运行

Javascript 是解释性语言，逐行解析，逐行执行。

浏览器首先按顺序加载由`<script>`标签分割的 js 代码块，加载 js 代码块完毕后，立刻进入以下三个阶段（语法分析、预编译、执行），然后再按顺序查找下一个代码块，再继续执行三个阶段。

### 2.1 语法分析

词法分析：将我们写的代码块分解成词法单元（token）。

语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树--抽象语法树（AST），并检查代码有没有什么低级的语法错误，如果有，引擎会停止执行并抛出异常。

### 2.2 预编译

在 Javascript 真正被解析之前，js 解析引擎会首先把整个文件进行**预处理**，以消除一些歧义，这个预处理的过程就被称为**预编译**，就是**创建执行上下文**。

**执行上下文**：( ExecutionContext，`EC` ) 就是代码的执行环境。

`EC`类型：

1. 全局执行上下文：任何不在函数内部的代码都在全局上下文中。
2. 函数执行上下文：每当**函数调用**的时候，会创建一个函数执行上下文。
3. Eval 函数执行上下文：执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文。

`EC`内容：

1. this 绑定（ThisBinding）
   - 在全局执行上下文中，`this` 的值指向全局对象。
   - 在函数执行上下文中，`this` 的值取决于该函数是如何被调用的。
2. 创建词法环境（LexicalEnvironment）
   - 环境记录器：存储变量和函数声明的实际位置。
     - 全局：
       - 创建 GO 对象；
       - 查找变量声明, 把变量名作为 GO 对象的属性名, 值为 undefined；
       - 查找函数声明, 把函数名作为 GO 对象的属性名, 值为函数体。
     - 函数：
       - 在函数被调用时, 为当前函数产生`AO对象`；
       - 查找形参和变量声明，把变量名和形参名作为`AO对象`的属性名, 值为 undefined；
       - 使用实参的值改变形参的值；
       - 查找函数声明, 把函数名作为`AO对象`的属性名, 值为函数体。
   - 外部环境的引用：通过其访问父级词法环境（作用域）
     - 全局：null。
     - 函数：可能是全局环境，或者任何包含此内部函数的外部函数。
3. 生成变量环境（VariableEnvironment）
   - 变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。
   - 词法环境用来存储函数声明和变量（`let` 和 `const`）绑定，而变量环境只用来存储 `var` 变量绑定。

**执行上下文栈**：用来存储代码运行时创建的所有执行上下文。

1. 当 JS 引擎第一次遇到脚本时，它会创建一个执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈顶。

2. 引擎会执行那些执行上下文位于栈顶的函数。
3. 当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。
4. **处于活动状态的执行上下文环境只有一个**。

### 2.3 执行

完成对所有这些变量的分配，最后执行代码。

## 3、作用域与作用域链

**作用域**：指程序中定义变量的区域，它决定了当前执行代码对变量的访问权限。

- 最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

- **函数在定义的时候就已经确定了函数体内部自由变量的作用域**。自由变量是当前作用域未定义的变量。

- 类型：
  - **全局作用域**：程序的最外层作用域，一直存在。
  - **局部作用域**：由函数产生的区域，包含在父级函数作用域 / 全局作用域内。
  - **块级作用域**：let 遇到除对象和函数等大括号以外的大括号（判断、循环）会形成块级作用域。
- 作用域和执行上下文的区别和联系
  - 创建时间不同：作用域在函数创建时创建；执行上下文在函数运行时创建。
  - 创建者不同：作用域是词法分析创建，是静态的；执行上下文是 js 引擎创建，是动态的。
  - 如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。
  - 一个作用域下可能包含若干个上下文环境，有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。

**作用域链**：由下往上或由里往外一层一层查找自由变量的关系。本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

- 自由变量要到**创建**这个函数的作用域中取值，其实就是静态作用域。

- 无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。
- 作用：在访问变量或者函数时, 会在作用域链上依次查找。即内部函数可以使用外部函数声明的变量。

## 4、闭包

**闭包是指有权访问另一个函数作用域中的变量的函数**。或者理解：当函数的执行，导致函数被定义，（并抛出）。

- 函数嵌套函数，内部函数就是闭包。
- 正常情况，函数执行完成，内部变量销毁；闭包，内部函数没有执行完，外部函数变量不会销毁。

**优点**：

- 被闭包引用的变量对象在程序结束后可以继续留在内存中(在函数外部能够访问到函数内部的变量)，实现变量数据共享**。（缺陷，内存泄露）**
- 利于代码封装，访问私有变量，方便调用上下文的局部变量**。（缺陷，不要随便改变父函数内部变量的值）**

**缺陷**：

- 内存泄漏：闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。

  - 解决方法：在退出函数之前，将不使用的局部变量全部删除。

    ```
    删除对象的属性       delete obj.name;
    删除其他	        str = undefined;
    删除不了原型链中的变量
    ```

- 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

### 4.4.1 闭包的应用场景

- setTimeout，闭包可以实现 setTimeout 传参效果
- 对 DOM 事件绑定，设置回调函数
- 函数防抖，触发事件 n 秒后再执行回调，如果在 n 秒内再次被触发，则重新计时。
- 封装私有变量

1）setTimeout：原生的 setTimeout 传递的第一个函数不能带参数，通过闭包可以实现传参效果。

```js
function f1(a) {
  return function f2() {
    console.log(a)
  }
}
setTimeout(f1(1), 1000) //一秒之后打印出1
```

2）回调：定义行为，然后把它关联到某个用户事件上（点击或者按键）。代码会作为一个回调（事件触发时调用的函数）绑定到事件。

```js
function changeSize(size) {
  return function () {
    document.body.style.fontSize = size + 'px'
  }
}
document.getElementById('myId').onclick = changeSize(20)
```

3）函数防抖：在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。

实现的关键就在于`setTimeOut`这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现。

```js
function debounce(fn, delay) {
  let timer = null
  return function () {
    // timer非空，说明当前正在一个计时过程中时又触发了相同事件。所以要取消当前的计时，重新开始计时
    if (timer) clearTimeout(timer)
    // 进入该分支说明当前并没有在计时，那么就开始一个计时
    timer = setTimeout(fn, delay)
  }
}
```

4）封装私有变量：

```js
var lanyu = (function () {
  let a = 2
  let b = 3
  function add() {
    console.log(a + b)
  }
  function sub() {
    console.log(a - b)
  }
  return {
    add,
    sub
  }
})()

lanyu.add()
lanyu.sub()
```

### 4.4.2 具体应用

**1）每隔一秒输出：0 1 2**

方案 1：立即执行函数 / 闭包

```js
for (var i = 0; i < 3; i++) {
  ;(function (x) {
    setTimeout(function () {
      console.log(x)
    }, 1000 * x)
  })(i)
} // 每隔一秒输出：0 1 2
// 改成：console.log(x+10); 	 每隔一秒输出：10 11 12

// 方法2，闭包的位置不同
for (var i = 0; i < 3; i++) {
  setTimeout(
    (function (x) {
      return () => {
        console.log(x)
      }
    })(i),
    1000 * i
  )
}
```

匿名函数作用域链记录的是**全局的变量对象（var i，作用域提升）**，因此会在真正执行的时候运用更新后 i 的值。现在只需要把每一轮循环 i 的值保存起来，用在回调函数里面；要保存 i 的值，我们可以修改一下回调函数的作用域链，让**回调函数的作用域链的变量对象（x）**指向每一轮的 i 的值，这里用立即执行函数来实现，立即函数可以引用每一轮循环时的 i 的值。

**方案 2：let 设置局部变量**

```js
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i)
  }, 1000 * i)
} // 每隔一秒输出：0 1 2
```

**2）私有变量/执行即输出**

情况 1：

```js
function generateId() {
  var i = 0
  return function () {
    console.log(i++)
  }
}
let generator = generateId()
var a = generator() // 输出0
var b = generator() // 输出1
generator() // 输出2
```

情况 2：

```js
function abc() {
  var flag = true
  return function () {
    if (flag) console.log(0)
    else console.log(1)
    flag = !flag
  }
}
abc() // 输出0
abc() // 输出1
abc() // 输出0
abc() // 输出1
```

## 5、this 绑定

在函数中 this 到底取何值，**是在函数真正被调用执行的时候确定的**，函数定义的时候确定不了。

**1）默认绑定**：函数直接调用 `f()`

- 非严格模式，this 指向 window
- 严格模式，this 指向 undefined，不会改变全局中 this 指向
- 全局变量用`let 或 const`定义，变量不会被绑定到`window`上

**2）隐式绑定**：函数作为对象的一个属性被调用 `obj.f()`

- this 指向调用对象
- 隐式丢失
  - 使用另一个变量来给函数取别名`var foo = obj.foo; foo()`
  - 将函数作为参数传递时会被隐式赋值，回调函数丢失 this 绑定`doFoo(obj.foo)`

**3）显式绑定**：函数用 call/apply/bind 调用 `f.call(obj)`

- this 指向传入的对象
- 如果`call、apply、bind`接收到的第一个参数是空或者`null、undefined`的话，则会忽略这个参数。

**4）new 绑定**：函数用构造器调用 `new F() `

- this 指向 new 出来的对象

**5）箭头函数绑定** `()=>{}`

- 箭头函数里面的 this 是由外层作用域来决定的。

- 箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 指向最近一层非箭头函数的 this，否则，this 为 undefined。

**调用模式优先级**：箭头函数绑定 > new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定

**6）class**

- 类的方法内部如果含有 this，它默认指向类的实例。但是，如果将这个方法（普通函数）提取出来单独使用，this 会指向该方法运行时所在的环境，又由于 class 中的方法已经在局部开启了严格模式，所以 this 实际指向的是 undefined；箭头函数的 this 和定义时的位置有关，始终是该箭头函数所在作用域中的 this，即实例。
