---
title: 防抖和节流
date: 2022-6-3
tags:
  - javascript
categories:
  - javascript
---

# 防抖和节流

**出现原因**：在进行窗口的 resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用防抖和节流的方式来减少调用频率，同时又不影响实际效果。

相同**：限制函数的执行次数**

不同：防抖是将多次执行变为最后一次执行，节流是将多次执行变为在规定时间内只执行一次。

## 1、防抖

**概念**：事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。

**应用场景**：

- 搜索框建议项：通常搜索框会提供下拉菜单，为用户当前的输入提供自动完成选项。但有时建议项是通过请求后端得到的。可以在实现提示文本时应用防抖，在等待用户停止输入一段时间后再显示建议文本。
- 按钮提交：防止多次提交按钮，只执行最后提交的一次。
- 服务端验证：对于一些特殊格式的输入项比如手机号、邮箱，通常会检查格式。我们可以应用防抖在用户停止输入一段时间后再进行格式检测，而不是输入框中内容发生改变就检测。
- 自动保存：例如掘金一类的网站，都会内嵌文本编辑器，在编辑过程中会自动保存文本，防止数据丢失。每次保存都会与后端进行数据交互，所以可以应用防抖，在用户停止输入一段时间后再自动保存。
- 消除 resize 事件处理程序的抖动：window 触发 resize 的时候，不断的调整浏览器窗口大小会不断触发这个事件，用防抖让其只触发一次。

**原理**：

- 通过定时器将回调函数进行延时，如果在规定时间内继续触发，发现存在之前的定时器，则将该定时器清除，并重新设置定时器。

**两种版本**：

- 非立即执行版：事件触发->延时->执行回调函数。如果在延时中，继续触发事件，则会重新进行延时；在延时结束后执行回调函数。常见例子：搜索框建议项、服务端验证、自动保存。
- 立即执行版：事件触发->执行回调函数->延时。如果在延时中，继续触发事件，则会重新进行延时；在延时结束后，并不会执行回调函数。常见例子：就是对于有立即反馈的按钮防重复点击，例如点赞、心标、收藏等。

```js
function debounce(fn, delay, immediate) {
  let timer = null
  let flag = true
  return function () {
    timer && clearTimeout(timer)
    if (immediate) {
      flag && fn.call(this, ...arguments)
      flag = false
      timer = setTimeout(() => {
        flag = true
      }, delay)
    } else {
      timer = setTimeout(() => {
        fn.call(this, ...arguments)
      }, delay)
    }
  }
}
```

## 2、节流

**概念**：在规定单位时间内只能有一次触发事件的回调函数执行，如果在同一个单位时间内又触发了该事件，则什么也不做，也不会重置定时器。

**应用场景**：

- 滚动事件：滚动事件处理程序应用节流，比如滚动加载、回到顶部。
- 拖拽元素：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动。
- 射击类游戏：不停点击鼠标，但以一定固定频率射击。
- 动画：避免短时间内多次触发动画引起性能问题 。

**两种版本**：

- 定时器版：
  - 通过闭包保存上一次定时器状态，事件触发时，如果定时器为 null(即代表此时间隔已经大于规定时间)，则设置新的定时器，到时间后执行回调函数，并将定时器置为 null。
  - 第一次不会立即，而是在 delay 秒后才执行；最后一次停止触发后，由于定时器 delay 延迟，可能还会执行一次（那也是上一次成功成功触发执行的回调，而不是你最后一次触发产生的）
- 时间戳版：
  - 通过闭包保存上一次的时间戳，与事件触发的时间戳比较，如果大于规定时间，则执行回调，否则就什么都不处理。
  - 第一次会立即执行；最后一次触发事件，也不会执行。

```js
// 节流-定时器
function throttle(fn, delay, immediate) {
  let timer = null
  return function () {
    if (!timer) {
      immediate && fn.call(this, ...arguments)
      timer = setTimeout(() => {
        !immediate && fn.call(this, ...arguments)
        timer = null
      }, delay)
    }
  }
}

// 节流-时间戳
function throttle(fn, delay, immediate) {
  let prev = 0
  return function () {
    let now = Date.now()
    if (now - prev > delay) {
      fn.call(this, ...arguments)
      prev = now
    }
  }
}
```

**总结：如果只关心最终状态，建议使用防抖；如果是想要函数以可控的速率执行，那么建议使用节流**。
