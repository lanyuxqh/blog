---
title: 计算机网络梳理
date: 2022-4-13
tags:
  - 计算机网络
  - 浏览器
categories:
  - 计算机网络
  - 浏览器
---

# 计算机网络梳理

## 1. 一次完整的 http 服务过程

当我们在 web 浏览器的地址栏中输入`www.baidu.com`，具体发生了什么？

1. 打开浏览器，输入 URL
2. 对网址进行 DNS 域名解析，得到相应的 IP 地址
3. 根据这个 IP 地址找到对应的服务器，发起 TCP 三次握手，建立 TCP 连接
4. 发送 HTTP 请求
5. 服务器响应 HTTP 请求，浏览器得到 html 代码
6. 浏览器解析脚本
7. 服务器关闭 TCP 连接，四次挥手

### 1. URL

**URL**：Uniform Resource Locator，统一资源定位符，是对资源的引用和访问该资源的方法。俗称网址。

一个 `URL` 由以下不同的部分组成：

- **协议**：通常是 [https](https://juejin.cn/post/6984991337841950757) 或 http，一种告诉浏览器或者设备如何访问资源的方法，当然还有其他的协议，如 `ftp` 、`mailto` 或者 `file`。
- `://`
- **主机名**：表示 IP 地址的注册名称（域名） 或 IP 地址，用于识别连接到网络的设备的数字标识符。
- **端口号**：可选，前面是冒号 `：` 。
- **路径**：可以引用文件系统路径，通常作为一个代码段使用。
- **查询**：可选，以问号开头的查询参数，其中多个参数用 `&` 连接
- **片段 ID**：可选，用于为页面上的标题提供快速链接，如锚点链接。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/869d1df45f5e452a85233a60f586025b~tplv-k3u1fbpfcp-watermark.awebp)

**URN**：Uniform Resource Name，统一资源名称，`URN`是`URI`的历史名字。

**URI**：Uniform Resource Identifier，统一资源标识符，提供了一种识别资源的方法。

URN 和 URL 都是 URI 的子集，URL 是指定位置的 URI，URN 是指定名称的 URI。

URL 住址协议://中国/广东省/广州市/番禺区/某大学/某宿舍楼/某宿舍/张三

URN 身份证号

### 2. DNS 查询过程

**DNS**：Domain Name System，域名系统。域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。

- DNS 是一个应用层协议，我们发送一个请求，其中包含我们要查询的主机名，它就会给我们返回这个主机名对应的 IP；
- DNS 是一个分布式数据库，整个 DNS 系统由分散在世界各地的很多台 DNS 服务器组成，每台 DNS 服务器上都保存了一些数据，这些数据可以让我们最终查到主机名对应的 IP。
- DNS 协议运行在 UDP 协议之上，使用端口号 53。
- DNS 服务器有 3 种类型：根域名（.）、顶级域名(`com `、`cn`、`org`、`edu` )、二级域名(baidu.com)、三级域名(www)。（自顶向下）
- **本地 DNS 服务器起着代理的作用**，并负责将该请求**转发**到 DNS 服务器层次结构中。

**DNS 解析过程**：

- **本地解析**

  - 先到浏览器的 DNS 缓存中查询是否有对应记录。如有则直接返回 ip 地址，完成解析，如果没有则下一步；

  - 然后到操作系统的 DNS 缓存查询是否有对应记录（查看本地 host 文件，比如 windows 的 host 文件一般位于“C:\Windows\System32\drivers\etc”）。如有则直接返回 ip 地址，完成解析；如果没有就去本地 dns 服务器上查找。

- **本地 DNS 服务器解析**

  - 本地 DNS 服务器可以分为两种：一种是公共 DNS 服务器，比如 114 DNS（114.114.114.114）、Google DNS（8.8.8.8）；另一种是本地运营商提供的 DNS 服务器，比如移动、电信提供的服务器。如有则直接返回 ip 地址，完成解析；如果没有就去根域名服务器查找。

- **根域名服务器**

  - 本地域名服务器向根域名服务器进行查询。根域名不会直接解析域名，而是把不同的解析请求分配给根域名下面的其他服务器来完成。以www.baidu.com为例：
  - 迭代查询：当**根域名服务器**接收到本地 DNS 服务器的解析请求后，获知后缀是.com，于是就把负责.com 的**顶级域名服务器**ip 返回给本地 DNS。本地 DNS 根据 ip 找到对应的顶级域名服务器，顶级域名服务器又把负责 baidu.com 的**二级域名服务器**ip 返回给本地 DNS。最后，本地 DNS 根据 ip 找到对应的二级域名服务器，二级域名服务器把www.baidu.com对应的主机ip返回给本地DNS，至此完成了域名解析的全过程。
    - 一般本地 DNS 服务器向其它 DNS 服务器的查询属于迭代查询
  - 递归查询：当**根域名服务器**接收到本地 DNS 服务器的解析请求后，获知后缀是.com，于是把解析请求发给负责.com 的**顶级域名服务器**。顶级域名服务器又把解析请求发给负责 baidu.com 的**二级域名服务器**。二级域名服务器把www.baidu.com对应的主机ip返回给顶级域名服务器，顶级域名服务器再返回给根域名服务器，根域名服务器最后返回给本地DNS服务器。
    - 一般客户机和本地 DNS 服务器之间属于递归查询

- **缓存**

  - 本地 DNS 服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03e22e0b48144817877972b034c4efef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:80%;" />

### 3. TCP/IP

#### 3.1 五层协议体系结构

**OSI 七层协议**：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

**TCP/IP 概念模型**：应用层、传输层、网络层、物理层

**五层协议体系结构**：应用层、传输层、网络层、数据链路层、物理层

- **应用层**：直接为用户的应用进程提供服务（FTP、HTTP、DNS、DHCP、TELNET、SMTP）
- 表示层：报文的格式转换、压缩、编码、加密。
- 会话层：发起、结束、管理**两个会话的通信。**
- **传输层**：上 3 层是数据处理阶段，下 3 层是数据传输阶段，具有承上启下的作用。主机中两个进程间的通信，为端到端连接提供可靠的传输服务、流量控制。**数据段**（TCP、UDP）
- 网络层：同一网络下，通过**路由选择算法**，为**数据包**在子网传输中选择合适路径。（ARP、IP、ICMP、IGMP）
- **数据链路层**：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输**数据帧**的数据链路。（PPP、CSMA/CD）
- **物理层**：通过传输介质进行物理连接，保证**比特流**的透明传输。

#### 3.2 TCP

##### 3.2.1 TCP 与 UDP

**1）TCP 报文段格式**

![img](/imgs/0147a9ace8f64a0ab7380b644197ec10.jpg)

1. 源端口和目的端口：各占 16bit，标识发送和接收终端中的不同应用进程。
2. 序号（sequence number）：占 32bit，本报文段发送的数据组的第一个字节的序号（TCP 连接传送的数据流中的每一个字节都会被编上一个序号）。
3. 确认号（acknowledgment number）：占 32bit，ACK 为 1 时有效，上次成功收到的数据【**最后一个字节**】序号+1，指明下一个期待收到的字节序号。
4. 数据偏移/首部长度：占 4bit，指示了数据区在报文段中的起始偏移值，实际上就是 TCP 报文段首部的长度。
5. 保留：占 6bit，为将来使用，目前设为 0。
6. 标志位：共 6 个，每一个标志位占 1bit，表示一个控制功能：
   1. URG：紧急指针标志，=1 时指示报文段中有紧急数据，应尽快传送，=0 时忽略紧急指针；
   2. ACK：确认号标志，=1 时表示确认号有效，=0 时表示报文段中不含确认信息，忽略确认号字段；
   3. PSH：push 标志，=1 时指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队；
   4. RST：复位标志，=1 时重置由于主机崩溃或其他原因而出现错误的连接，或者用于拒绝非法的报文段和拒绝连接请求；
   5. SYN：同步标志，用于建立连接过程。当 SYN=1 且 ACK=0 时，表示这是一个连接请求报文段。若同意连接，响应的报文段中 SYN=1 且 ACK=1；
   6. FIN：结束标志，=1 时表明此报文段的发送方已经没有数据需要发送了，并要求释放连接。
7. 窗口：占 16bit，表示滑动窗口大小，用来告知发送端接收端的缓存大小，以此控制发送端发送数据的速率。是动态改变的。
8. 校验和：占 16bit，奇偶校验，校验范围包括首部和数据两个部分，由发送端计算和存储，并由接收端进行验证。
9. 紧急指针：占 16bit，只有当 URG =1 时紧急指针才有效。他指出了本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），因此紧急指针指出了紧急数据的末尾在报文段中的位置。
10. 选项和填充：可选字段，长度为 0~40B，必须以 4B 为单位，必要时可以填充 0。通常可以包括最长报文段大小、窗口扩大选项、时间戳选项等。
11. 数据部分：可选，比如在连接建立和终止时，仅有 TCP 首部而没有数据部分。

**2）UDP 数据段格式**

![img](\imgs\af2e94deab454944911ea82b239b8f9f.jpg)

1. 源端口和目的端口：各占 16bit，标识发送和接收终端中的不同应用进程。
2. UDP 总长度：占 16bit，指示 UDP 报文（首部和数据）的总长度。
3. 校验和：该字段用于发现头部信息和数据中的错误。
4. 数据部分：可选。

**3）TCP 和 UDP 的区别**

**TCP 是一个面向连接的、可靠的、基于字节流的传输层协议。**

**UDP 是一个面向无连接的传输层协议。**

具体来说，

- **面向连接**：在发送数据前，TCP 会通过三次握手在两个主机之间先建立一条连接，而 UDP 不会，而是直接发送数据。
- **可靠性**：TCP 花了非常多的功夫保证连接的可靠。TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是**有状态**。当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。而 UDP 就是无状态、不可控的。

- **面向字节流**：TCP 的数据传输是面向字节流的，每个 TCP 套接口会有一个发送缓冲区，如果字节流太长时，TCP 会将其拆分进行发送。当字节流太短时，TCP 会等待缓冲区中的字节流达到一定程度时再构成报文段发送出去。对于接收方的缓冲区，只要能够容纳，它会一次性接收所有到达的数据。UDP 的数据传输是面向报文段的，对于应用层交下来的报文，在添加首部后就向下交付给网络层，既不合并，也不拆分，而是保留这些报文的边界。
- **通信**：TCP 只能是一对一通信，UDP 支持一对一，一对多，多对一和多对多交互通信
- **首部开销**：TCP 首部最小 20 字节，最大 60 字节，UDP 首部开销小，仅 8 字节
- **应用场景**：TCP 适用于效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有 UDP 高。比如，文件传输（准确高要求高、但是速度可以相对慢）、接收邮件、远程登录。UDP 适用于效率要求相对高，对准确性要求相对低的场景。比如，QQ 聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

##### 3.2.2 TCP 的可靠传输

- 目的：使数据可以毫无遗漏地交给对方。

- 实现：

  - **校验**：TCP 报文头有校验和，用于检验报文是否损坏；

  - **序号**：用来保证数据能有序提交给应用层；

  - **确认**：告诉对方期望收到对方的下一个报文段数据的第一个字节是什么；

  - **重传**：发送一段时间后没有收到确认就会重传；

##### 3.2.3 TCP 的流量控制

- 目的：让发送方的发送速率不要太快，让接收方来得及接收，防止分组丢失。
- 实现：由滑动窗口协议实现，接收方返回的 ACK 中会包含自己的接收窗口的大小。

- **数据合理分片和排序**：tcp 会按最大传输单元（MTU）合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。
  - **而 UDP 中**：IP 数据报大于 1500 字节，大于 MTU。这个时候发送方的 IP 层就需要分片，把数据报分成若干片，使得每一片都小于 MTU。而接收方 IP 层则需要进行数据报的重组。由于 UDP 的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个 UDP 数据报

##### 3.2.4 TCP 的拥塞控制

- 目的：防止过多的数据注入到网络中，避免出现网络负载过大的情况。
- 判断依据：发送方没有按时收到应当到达的确认报文。
- 实现：
  - 慢开始：不要一开始就发送大量数据，先探测下网络的拥塞程度，从小到大逐渐增加拥塞窗口大小；
  - 拥塞避免：让拥塞窗口按线性增长；
  - 快重传：当发送方连续收到三个重复确认，就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期；
  - 快恢复：当发送方连续收到三个重复确认，就立即执行“乘法减小”算法，将拥塞窗口设置为慢开始门限减半后的值，然后执行拥塞避免算法，使拥塞窗口缓慢增大；

##### 3.2.5 TCP 三次握手/四次挥手

**1）三次握手建立连接**

![img](\imgs\9108d9e30fc14e51a3fdcd4d33bf7bbc.jpg)

1. **请求**：客户端向服务器端发起连接请求，附带一个同步标志 SYN=1，序列号 seq=x（客户端进入**同步发送**状态）
2. **同意，打算连接**：服务器端收到请求报文后，如果同意建立连接，就发送一个同步标志 SYN=1，序列号 seq=y，确认标志 ACK=1，确认号 ack=x+1（服务器端进入**同步收到**状态）
3. **确认**：客户端收到响应报文后，向服务器端发送一个确认报文，序列号 seq=x+1，确认标志 ACK=1，确认号 ack=y+1（客户端进入**连接建立**状态）

**2）四次挥手释放连接**

![img](\imgs\86b6ab1f8116437a869c24a0d4112574.jpg)

1. **打算关闭**：客户端向服务器端发起连接释放，附带一个结束标志 FIN=1，序列号 seq=u（客户端进入**终止等待 1**状态）
2. **同意**：服务器端收到请求报文后，如果同意释放连接，就发送序列号 seq=v，确认标志 ACK=1，确认号 ack=u+1（服务器端进入**关闭等待**状态），此时处于半关闭状态，服务器还可以向客户端发送数据，客户端收到服务器的确认报文段后，（客户端进入**终止等待 2**状态）
3. **打算关闭**：服务器端向客户端发送连接释放报文段，附带一个结束标志 FIN=1，序列号 seq=w，确认标志 ACK=1，确认号 ack=u+1，（服务器进入**最后确认**状态）
4. **确认**：客户端收到连接释放报文后，向服务器端发送一个确认报文，序列号 seq=u+1，确认标志 ACK=1，确认号 ack=w+1，（客户端进入**时间等待**状态），此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态。服务器接收到确认报文段后，立即进入 CLOSED 状态。

**3）常见问题**

- **为什么需要三次握手？ == 为什么 TCP 客户端最后还要发送一次确认？**

  - 主要防止已经失效的连接请求报文段突然又传送到了服务器，从而产生错误。

    - A 发送请求，但连接请求报文堵塞，B 并未收到确认，所以 A 再重传一次连接请求并根据这次请求建立了连接，数据传输完后就释放了连接。此时第一次发送的堵塞住的报文到达了 B，B 会误以为 A 又一次发送了连接请求，然后发出确认报文，然后新的连接就建立了。

  - 三次握手才能确认双方的接收与发送能力是否正常，如果只有两次握手的话，服务端无法确认客户端是否有接收数据的能力。

- **第三次握手失败会出现什么问题？**

  - 如果 ack 包在网路中丢失，时间超过了计时器，server 端会重发 SYN+ACK 报文，默认 5 次，如果仍未收到响应，那么将发送 RST 报文关闭连接（RST 异常连接重置报文）；

  - 如果有大量的客户端不进行第三次握手，server 端会一直重发 syn+ack 报文，并且半连接队列会逐渐堆满，无法处理正常请求。

- **为什么客户端最后还要等待 2MSL(四分钟)？**

  - 保证客户端发送的最后一个 ACK 报文段能够到达服务器，因为这个 ACK 报文段可能丢失；一旦丢失，服务器重新发送连接释放报文段时（**超时重传**），客户端就能在这个 2MSL 时间段内收到这个重传的报文段，接着给出回应报文段，并且会重启 2MSL 计时器。

  - 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文段后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文段。

- **为什么建立连接是三次握手，关闭连接确是四次挥手呢？**

  - 建立连接时，服务器收到建立连接请求的 SYN 报文段后，把 ACK 和 SYN 放在一个报文段里发送给客户端；

  - 释放连接时，在客户端发送完数据请求释放连接的情况下，服务器可能仍还有数据需要发送给客户端，因此将**ACK 和 FIN 分开发送**，从而导致多了一次。

### 4. HTTP/HTTPS

HTTP（超文本传输协议）是基于 TCP 的应用层协议，主要用来规范客户端和服务器的数据传输格式。

#### 4.1 HTTP 版本

**http0.9**

- 仅支持 GET 请求；
- 没有请求头、状态码、版本号等描述数据的信息；
- 只能发送 HTML 格式字符串；
- 服务器发送完毕，就关闭 tcp 协议。

**http1.0**

- 增加了 POST、HEAD 请求；
- 增加了请求头、状态码 ；
- 传输内容不限于 HTML 文件；
- 缺点：默认短连接，一次请求建立一次 TCP 连接，请求完就断开，性能较差。
  - 有些浏览器在请求时，采用非标准连接字段。`Connection：keep-alive`

**http1.1**

- 增加了 PUT、DELETE、CONNECT、TRACE、PATCH、OPTIONS 请求；
- 请求头中增加 host 字段；
- 支持文件断点续传；（Range）
- 支持分块传输编码；（Transfer-Encoding）
- 持久连接，请求管道化；（在同一个 TCP 连接里，允许多个请求同时发送，增加了并发性）
- 缺点：
  - 同一个 TCP 连接中，队列堵塞。
    - 减少请求
    - 同时多开几个 TCP 连接，对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接

**SPDY**

针对 HTTP1.X，优化了的请求延迟，解决了安全性。

- 多路复用：降低了延迟同时提高了带宽的利用率。
- header 压缩： DEFLATE 算法
- 服务端推送
- **使用二进制分帧层**
- **数据流优先级**：对数据流设置优先值，决定了客户端和服务端处理不同的流采用不同的优先级策略。
- **基于 HTTPS 的加密协议传输**，大大提高了传输数据的可靠性。

SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议(将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。

<img src="/Users/xqh/Desktop/秋招资料/前端笔记-盛萱/.\fig\image-20200825215227258.png" alt="image-20200825215227258" style="zoom: 50%;" />

**http2.0**

HTTP 2.0 是 SPDY 的升级版。**HTTP2.0 和 SPDY 的区别**：

1. HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
2. HTTP2.0 消息头的压缩算法采用 HPACK ，非 SPDY 采用的 DEFLATE

- **使用二进制分帧层**

  HTTP 1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP 2.0 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame），即头信息帧和数据帧。

- **多路复用**

  HTTP2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，不用按照顺序一一对应，而且并发请求的数量比 HTTP1.1 大了好几个数量级。把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方。流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题。

- **头信息压缩**

  HTTP1.1 不支持 header 数据的压缩，随着 Web 功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，完全是一种浪费。HTTP2.0 使用 HPACK 算法对 header 的数据进行压缩；同时客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号。

- **服务端推送**

  当我们对支持 HTTP 2.0 的 web server 请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取，这种方式非常合适加载静态资源。 服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了。

- **数据流优先级**

  对数据流可以设置优先值，这个优先值决定了客户端和服务端处理不同的流采用不同的优先级策略。（例如浏览器在等待关键的 CSS 或者 JS 文件完成对页面的渲染时，服务器却在专注于加载图片）

**HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？**

- HTTP/1.0 每一个请求都要建立一个连接；
- HTTP/1.1 请求管道化，若干个请求排队串行化单线程处理，存在线头阻塞问题；
- HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。

**http3.0/QUIC**

HTTP3.0 核心是 QUIC 协议，是基于传输层 UDP 的安全可靠的 HTTP2.0 协议，由 Google 在 2015 年提出的 SPDY v3 演化而来的新协议。

- **减少了 TCP 三次握手及 TLS 握手时间**：

  HTTP1.0/1.1/2.0/HTTPS 都使用了 TCP 进行传输，HTTP2/HTTPS 还需要使用 TLS 协议来进行安全传输。这就存在两个握手延迟，而基于无连接 UDP 协议的 QUIC，连接建立时只需要一次交互，相当于半个握手的时间。

- **连接迁移**：

  QUIC 连接不以四元组作为标识（源 IP、源端口、目的 IP、目的端口）（连接变换时就需要切换 TCP 连接），而是使用一个 64 位的随机数 Connection ID，对应每个 stream，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持。

- **解决多路复用丢包时的线头阻塞问题**：

  QUIC 中一个连接上的多个 stream 之间没有依赖。所以当发生丢包时，只会影响当前的 stream，从而避免线头阻塞问题。

- **优化重传策略**：

  TCP 中重传序号一致问题而导致的发送端不能明确 ACK 是初始包的确认还是对重传包的确认。为了避免这一问题，QUIC 发送端设置初始与重传的每一个封包都改用一个新的编号，unique packet number，每一个编号都唯一而且严格递增，这样每次在收到 ACK 时，就可以依据编号明确的判断这个 ACK 是来自初始封包或者是重传封包。

- **流量控制**：

  QUIC 为了避免出现流量极慢的 stream，采用了连线层 (connection flow control) 和 Stream 层的 (stream flow control) 流量控制，限制单一 Stream 可以占用的最大 buffer size。

#### 4.2 HTTP 报文格式

**HTTP 请求报文**由请求行、请求头、请求体三个部分组成。

![img](\imgs\df44746aa33d480c89cfbf32ddd64a01.jpg)

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ca77a9358048359f2c5b90d8fc4bd2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="在这里插入图片描述" style="zoom:50%;" />

1. 请求行：包括请求方法、请求 URL、协议及版本。
2. 请求头：由一堆键值对组成，用来说明服务器要使用的一些附加信息，比如请求的目的地、客户端信息、Cookie 等。

   - **Accept: text/html** 浏览器能够接收的内容类型。
   - **Accept-Charset: utf-8, iso-8859-1;q=0.5** 浏览器能够接收的字符编码。
   - **Accept-Encoding: gzip, deflate** 浏览器可以支持的压缩编码类型。
   - **Accept-Language: zh-CN,zh;q=0.9** 浏览器接收的语言。
   - **Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ** 在 HTTP 中，服务器可以对一些资源进行认证保护，如果你要访问这些资源，就要提供用户名和密码，这个用户名和密码就是在 Authorization 头中附带的。basic 指使用 basic 认证方式，QWxhZGRpbjpvcGVuIHNlc2FtZQ 使用 base64 解码就是 Aladdin:open sesame。
   - **Cache-Control: max-age=0** 缓存机制。
   - **Connection: keep-alive** 表示是否需要持久连接。当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
   - **Content-length: 10** 请求体的内存长度
   - **Host: www.baidu.com** 指定请求的服务器的域名和端口号。
   - **Cookie:** HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给服务器。
   - **Referer: https://www.baidu.com/?tn=62095104_8_oem_dg** 告诉服务器我是从哪个页面链接过来的。
   - **User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36** 告诉服务器客户端使用的操作系统和浏览器的名称和版本。
   - **Range: bytes=0-5** 取请求资源的从某个数值到某个数值间的数据。

3. 请求体：存放一些需要和服务器端交互的数据。

**HTTP 响应报文**由状态行、响应头、响应体三个部分组成。

![img](\imgs\d155b70164e64777b3534083dc5cd69f.jpg)

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bafeb9a8323a4ca4add4a6be3f99f1a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="在这里插入图片描述" style="zoom:80%;" />

1. 状态行：包括协议及版本、状态码及状态描述。
2. 响应头：由一堆键值对组成，用来说明客户端要使用的一些附加信息，比如响应时间、数据类型等。

   - **Accept-Ranges: bytes** 服务器表示自己是否接受获取某个实体的一部分的请求，bytes:接受 none:不接受。
   - **Access-Control-Allow-Origin: \*** 指定哪些网站可以跨域源资源共享。
   - **Access-Control-Allow-Methods：GET,POST,PUT,DELETE** 允许哪些方法来访问。
   - **Access-Control-Allow-Credentials: true** 是否允许发送 cookie。
   - **Age: 234585576** 响应对象在代理缓存中存在的时间。
   - **Content-Type：text/html;charset=UTF-8** 告诉浏览器资源文件的类型和字符编码。
   - **Content-Encoding：gzip** 服务器采用的压缩编码类型。
   - **Date: Tue, 03 Apr 2018 03:52:28 GMT** 响应消息发送的 GMT 格式日期，GMT 是格林尼治所在地的标准时间。
   - **Server：Tengine/1.4.6** 服务器和版本。
   - **Refresh: 5; url=http://baidu.com** N 秒之后刷新本页面或访问指定页面。
   - **Location: ../adv.html** 通知浏览器文档的地址，浏览器会自动重新连接到这个位置，并获取新的文档。
   - **Via: 1.0 [example1.com](https://link.juejin.cn/?target=http%3A%2F%2Fexample1.com%2F), 1.1 [example2.com](https://link.juejin.cn/?target=http%3A%2F%2Fexample2.com%2F) (Apache/1.1)** 该响应经历了那些代理。
   - **Transfer-Encoding：chunked** 服务器发送的资源是分块发送的。

3. 响应体：存放服务器返回给客户端的文本信息。

#### 4.3 请求方法

| **请求方法** | **方法描述**                                                                     | **支持的 HTTP 版本** |
| ------------ | -------------------------------------------------------------------------------- | :------------------: |
| GET          | 常用于向服务器请求资源、查询信息                                                 |       1.0，1.1       |
| POST         | 向服务器新增更新数据，偏向于新增数据                                             |       1.0，1.1       |
| PUT          | 向指定资源位置新增更新数据，偏向于更新数据                                       |       1.0，1.1       |
| HEAD         | 与 GET 方法类似，只是响应报文没有数据主体，用于确认 URI 的有效性及资源更新时间等 |       1.0，1.1       |
| DELETE       | 请求服务器删除指定的资源                                                         |       1.0，1.1       |
| OPTIONS      | 用来询问服务器支持的方法（非简单请求的预检）                                     |         1.1          |
| TRACE        | 追踪路径，回显服务器收到的请求，确认客户端发送出去的请求是否被修改过             |         1.1          |
| CONNECT      | 要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信                    |         1.1          |
| PATCH        | 用于对资源进行部分修改                                                           |                      |

##### 4.3.1 GET 和 POST 区别

- **应用场景**：GET 一般用来从服务器上获得数据（查），而 POST 是用来向服务器上传数据（增删改）。

- **大小**：GET 方式传输的数据量较小（长度有限制<=2Kb），而 POST 可以传输大量的数据（无限制，靠服务器的设定值限制）

- **安全程度**：GET 请求参数放在 URL 中，POST 放在 request body 中，所以 POST 会相对更安全。

- **幂等性**：GET 是幂等方法，POST 是非幂等方法。

  - 幂等性是后端接口承诺只要接口调用成功，一次请求和重复的多次请求**对系统资源的影响是一致的，具有相同的副作用（而不是结果相同）**。

    以 post 方法为例，它的目的是在服务端创建一份资源，但是由于它不满足幂等性，所以当使用 post 方法重复提交相同的数据时（比如重复提交表单），会在服务端创建出多份资源，这就是 post 方法的副作用。

    - **幂等方法**：GET、HEAD、PUT、DELETE、OPTIONS
      - GET 方法用于获取资源，不会改变资源的状态，不论调用一次还是 N 次都没有副作用。
      - DELETE 方法用于删除资源，调用一次和 N 次对系统产生的副作用是相同的，即删掉 id 为 4231 的帖子。
    - **非幂等方法**：POST、PATCH

- **参数类型**：GET 只接受 ASCII 字符，而 POST 没有限制。

- **数据包**：GET 产生一个 TCP 数据包，浏览器会把 http header 和 data 一并发送出去，服务器响应 200 返回数据；POST 产生两个 TCP 数据包，浏览器先发送 http header，服务器响应 100 等待其余部分，浏览器再发送 data，服务器响应 200 返回数据，所以 POST 传输速度更慢。**注意**：并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次。

##### 4.3.2 POST 和 PUT 区别

二者均可用于创建资源

- **URI 意义**：POST 所对应的 URI 并非创建的资源本身，而是资源的接收者。比如：POST [http://www.forum.com/articles](https://link.jianshu.com?t=http%3A%2F%2Fwww.forum.com%2Farticles)的语义是在[http://www.forum.com/articles](https://link.jianshu.com?t=http%3A%2F%2Fwww.forum.com%2Farticles)下创建一篇帖子，HTTP 响应中应包含帖子的创建状态以及帖子的 URI。PUT 所对应的 URI 是要创建或更新的资源本身。比如：PUT [http://www.forum/articles/4231](https://link.jianshu.com?t=http%3A%2F%2Fwww.forum%2Farticles%2F4231)的语义是创建或更新 ID 为 4231 的帖子。
- **幂等性**：POST 是非幂等方法；PUT 是幂等方法。
  - 两次相同的 POST 请求会**在服务器端创建两份资源**，它们具有不同的 URI。
  - 对同一 URI 进行多次 PUT 的副作用和一次 PUT 是相同的。

##### 4.3.4 PUT 和 PATCH 区别

二者均可用于更新资源

- **幂等性**：PUT 是幂等方法；PATCH 是非幂等方法。

- **整体和局部**：PUT 需要把整个 json 发过去，可以做到直接覆盖；PATCH 用来对已知资源进行局部更新，只需要发送 json 中需要更改的字段。

#### 4.3.5 GET 和 HEAD 区别

两者均可用于从服务器获取资源

- **返回**：HEAD 请求服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”；GET 会返回请求的实体数据。
  - 比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。

#### 4.4 状态码

| **状态码分类** | **分类描述**                                     |
| -------------- | ------------------------------------------------ |
| 1\*\*          | 指示信息，服务器收到请求，需要请求者继续执行操作 |
| 2\*\*          | 成功，操作被成功接收并处理                       |
| 3\*\*          | 重定向，需要进一步的操作以完成请求               |
| 4\*\*          | 客户端错误，请求包含语法错误或无法完成请求       |
| 5\*\*          | 服务器错误，服务器在处理请求的过程中发生了错误   |

**常见的状态码**

- 100：【Continue】请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。

- 101：【切换协议】请求者要求服务器切换协议，服务器已确认并准备切换。

- 102：代表处理将被继续执行（ 由 WebDAV（RFC 2518）扩展的状态码）

- **200**：【OK】请求被成功处理

- 201：【Created】请求已经被成功处理，并且创建了新的资源。新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 Location 首部的值。

- 203：表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。 （HTTP 1.1 新增）

- 204：【No Content】 请求已被处理成功，但是没有数据实体返回，此时浏览器页面也不会发生更新

- **206**：【Partial Content】当客户端进行了范围请求且被成功处理时返回， 比如断点续传或多线程下载时会看到该状态码

- **301**：【Moved Permanently】表示请求的资源已经**永久**搬到了其他位置，新的 URI 应该提示在响应头的 Location 字段；这个响应是可缓存的；搜索引擎会抓取新地址的内容，同时将网址保存为新地址。

- **302**：【Found】表示请求的资源**临时**搬到了其他位置，新的临时 URI 应该提示在响应头的 Location 字段（虽然协议禁止请求重新发送，但实际使用时浏览器都会这么做）；只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的；搜索引擎会抓取新地址内容，但是会将网址保存为旧地址。

- 303：【See Other】与 302 意义一样，区别只是 303 明确客户端应该使用 GET 访问（请求 会自动再次发送）

- **304**：【Not Modified】表示客户端发送附带条件的请求（GET 方法请求报文中的 IF…）时，服务端允许访问，但没有满足条件。（其实和重定向没啥关系，常用于检查**缓存**是否有更新）

- 307：【Temporary Redirect】与 303 意义一样，只是客户端在收到该状态码的响应时，会遵循标准，不会自动把 POST 变为 GET 再次放出请求

- **400**：【Bad Request】表示请求报文存在语法错误或参数错误，服务器不理解

- **401**：【Unauthorized】表示发送的请求需要有通过 HTTP 认证信息或者是认证失败了

- **403**：【Forbidden】表示对请求资源的访问被服务器拒绝了，一般可能是因为权限问题

- **404**：【Not Found】表示请求的资源在服务器上找不到

- 405：【Method Not Allowed】表示客户端请求的方法被禁止

- 409：【conflict】表示请求的资源与资源的当前状态发生冲突

- 410：【Gone】表示服务器上某个资源被永久性删除。

- **500**：【Internal Server Error】服务器内部发生了错误

- **502**：【Bad GateWay】网关错误

- **503**：【Service Unavailable】表示服务器超负载或正停机维护，目前无法处理请求，可以将延时写在响应头的 Retry-After 字段返回

- 505：【HTTP Version not supported】服务器不支持请求的 HTTP 协议的版本，无法完成处理

**302 详解**：根据协议标准，若客户端发出 POST 请求后，收到 302 状态码，不能自动的向新的 URI 发送重复请求，必须跟用户确认是否该重发，但实际上许多客户端在这种情况下都会把 POST 请求变为 GET 请求。新增的 303 和 307 其实就是明确了两种处理方式，303 允许自动转换并发出请求，而 307 不允许。

#### 4.5 HTTP 特点

- 灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
- 可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。
- 请求-应答。也就是`一发一收`、`有来有回`， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演**请求方**的角色。
- 无状态。这里的状态是指**通信过程的上下文信息**，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。

#### 4.6 HTTPS

https 是在 http 的基础上加入了 SSL 协议，因为 http 协议以明文方式发送内容，不提供任何方式的数据加密，容易被第三方通过网络抓包截取和篡改报文。**SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密**，弥补了 http 的安全缺陷。

- **HTTPS 设计目标**：

  - 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么。
  - 数据完整性：即使发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里面装了什么东西，但他有可能中途碉堡，数据完整性就是指如果被掉包，我们能轻松发现并拒收。
  - 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹是，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方。

- **SSL 和 TLS**：

  - SSL（Secure Sockets Layer）安全套接层。用于保证（world wide web，WWW）的通讯安全。主要任务是提供私密性，信息完整性和身份认证。SSL 是一个不依赖于平台和运用程序的协议，位于 TCP/IP 协议与各种应用层协议之间，为数据通信提高安全支持。

    - **SSL 证书中包含的具体内容**有：

      （1）证书的发布机构 CA

      （2）证书的有效期

      （3）公钥

      （4）证书所有者

      （5）签名

    - 客户端在接受到服务端发来的 SSL 证书时，会**对证书的真伪进行校验**，以浏览器为例说明如下：

      （1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验

      （2）浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发

      （3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。

      （4）如果找到，那么浏览器就会从操作系统中取出 颁发者 CA 的公钥，然后对服务器发来的证书里面的签名进行解密

      （5）浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值，将这个计算的 hash 值与证书中签名做对比

      （6）对比结果一致，则证明服务器发来的证书合法，没有被冒充

      （7）此时浏览器就可以读取证书中的公钥，用于后续加密了

    - SSL 的体系结构中包含两个协议子层，其中底层是 SSL 记录协议层；高层是 SSL 握手协议层：

      - **SSL 记录协议层**的作用是为高层协议提供基本的安全服务。SSL 记录协议针对 HTTP 协议进行了特别的设计，使得超文本的传输协议 HTTP 能够在 SSL 运行。记录封装各种高层协议，具体是是压缩解压缩、加密解密、计算和校验 MAC 等与安全有关的操作。

      - **SSL 握手协议层**包括 SSL 握手协议、SSL 密码参数修改协议和 SSL 告警协议。握手协议层的这些协议用于 SSL 管理信息的交换，允许应用协议传送数据之间相互验证，协商加密算法生成密钥等。**SSL 握手协议的作用是协调客户和服务器的状态，使双方能够达到状态的同步。**

  - TLS（Transport Layer Security，传输层安全协议）用于在两个通信应用程序之间提供保密性和数据完整性。

##### 4.6.1 HTTPS 传输过程

（SSL 安全传输协议用来鉴别网站和网页浏览者的身份,以及在浏览器使用者及网页服务器之间进行加密通讯的全球化标准协议。）

![img](/Users/xqh/Desktop/秋招资料/前端笔记-盛萱/.\fig\5b503d10e4b0edb750e0d4f8.png)

<img src="https://cdn.nlark.com/yuque/0/2020/png/1743874/1595053832185-1e1be9c9-5a89-4e88-98c7-200da06c9d48.png" alt="img" style="zoom:80%;" />

1. **申请认证**：服务器生成一对公私钥，将公钥放在证书中（域名、申请者、公钥），生成请求文件.csr 发给 CA 进行审核，CA 审核过后，得到服务器最终的证书，对证书取 hash 得到摘要，然后对摘要进行加密得到数字签名，然后将包含数字签名的证书给服务器。
   - **CA 证书包含**：服务器的公钥、域名，证书的数字签名、颁发机构、过期时间、申请者等。
   - 服务器的证书也可以自己制作，自己颁发的证书需要客户端验证通过，才可继续访问，而使用 CA 证书则不会弹出提示页面。
2. **发起请求**：客户端发起 https 请求（连接到服务器的 443 端口）
3. **发送证书**：服务器收到客户端请求后，会将从 CA 申请的服务器 CA 证书返回给客户端。
4. **验证证书**：客户端解析并对证书进行验证。浏览器会内置一个受信任的 CA 机构列表（白名单），并保存了这些 CA 机构的证书。浏览器会基于这些内置信息核对服务器证书。如果发现异常，则会弹出一个警告框，提示证书存在问题。使用 CA 公钥对数字签名进行解密得到摘要，同时对证书取 hash 得到原始摘要，比对两者。
5. **生成通信密钥**：在本地生成一个通信密钥，并取出证书中服务器的公钥对密钥进行加密，然后返回给服务器。
6. **获得通信密钥**：服务器用自己的私钥解密后，得到对称密钥。之后双方传输的所有 http 数据，均通过对称密钥进行加解密。

**问：如何保证两边生成对称密钥是相同的？**

对称密钥**enc_key=Fuc(random_C, random_S, Pre-Master)**，其中 random_C 和 random_S 分别在客户端和服务端随机生成，Pre-Master 是在第 5 步随机生成的。第 5 步会向服务端发送以下字段：

- `ClientKeyExchange`：客户端产生的随机数字 Pre-master，用 server 的公钥加密，发送给服务器

- `ChangeCipherSpec`：客户端通知服务器后续的通信都采用协商的对称密钥和加密算法进行通信（注意这个消息里不包含对称密钥）

- `Finished`：结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与对应算法进行加密，即`EncryptedHandshakeMessage`，发送给服务器

**问：如何防止中间人攻击？**数字签名（证书，相当于验证了公钥的合法性）

**扩展：过程中的非对称和对称加密**：

- 协商秘钥的过程用了**非对称加密**，特点是私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。
  - 特点：安全性更高；但加解密十分费时
- 真正通信的过程是使用**对称加密**。加密和解密使用同一个秘钥。
  - 特点：加密速度快、效率高；秘钥的管理和分发非常困难，不够安全。

##### 4.6.2 非对称加密和对称加密

**Hash 加密算法**：MD5、SHA-256、SHA512

**非对称加密**

用私钥加密过的信息可以用很多公钥加密，而用公钥加密过的信息只有私钥能解密。私钥只有一把，而公钥有很多。

- 优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。

- 缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

- 主要算法：RSA、Elgamal、背包算法、Rabin、HD,ECC（椭圆曲线加密算法）。常见的有：RSA，ECC
- 我们常见的数字证书、加密狗即是采用非对称加密来完成安全验证的。

**对称加密**

指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。

- 优点：算法公开、计算量小、加密速度快、加密效率高。

- 缺点：秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。
- 具体算法有：DES，3DES，TDEA，Blowfish，RC5，IDEA。常见的有：DES，AES，3DES 等等。

**区别**

对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用。

##### 4.6.3 HTTP 和 HTTPS 的区别

1. https 协议需要到 CA 申请证书或自制证书。
2. http 的信息是明文传输，https 则是具有安全性的 ssl 加密。
3. http 是直接与 TCP 进行数据传输，而 https 是经过一层 SSL（OSI 表示层）进行数据加密，
4. 端口不一样，http 是 80（需要国内备案），https 是 443。
5. http 的连接很简单，是无状态的；https 是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

**无状态的含义**：客户端给服务器发送 HTTP 请求，服务器响应后，不会记录任何信息，没有记忆功能。（解决方案：cookie、session）

**无连接的含义**：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。

### 5. 浏览器渲染

#### 5.1 关键渲染路径

关键渲染路径（CRP）是浏览器将 HTML CSS JavaScript 转换为呈现在屏幕上的像素内容所经历的一系列步骤。

1. 解析 HTML 构建 DOM 树
2. 解析 CSS 构建 CSSOM 树
3. 将 DOM 树与 CSSOM 树合并在一起生成渲染树（Render Tree）
4. 布局（layout/reflow）渲染树，计算每个节点在页面中的位置大小
5. 绘制（paint）渲染树，将像素绘制到屏幕上

上面的过程并不是次序进行的，而是存在一定交叉。

![workflow](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/7/16f7ee2d9a5667b3~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

**构建 DOM**：从资源的字节流到 DOM 树。

1. 将字节流（二进制）通过解码成字符流
2. 将字符流通过词法分析器解析成 Tokens------HTMLTokenizer 类、XSSAuditor 类
3. 将 Tokens 通过语法分析器构建成节点------HTMLDocumentParser 类、 HTMLTreeBuilder 类
4. 将这些节点组合成一颗 DOM 树-------HTMLConstructionSite 类

该过程是循序渐进的，浏览器得到一部分 HTML 后就开始构建 DOM，加快构建过程。因为自顶向下构建，后面的构建不会对前面造成影响。

**构建 CSSOM**：当 HTML 解析中遇到`<link>`标签时，会请求对应的 CSS 文件，当 CSS 文件就位时便开始解析它，这一解析过程与构建 DOM 同时进行。如果是外部样式，CSSOM 的构建必须要获得一份完整的 CSS 文件，和 DOM 构建的循序渐进有所区别。因为 CSS 文件中包含大量样式，后面的样式会覆盖前面的样式，若提前构建可能会得到错误的结果。

- 内联样式：CSSOM 构建包含在解析 HTML 中。
- 外部样式，CSSOM 构建包含在解析 Stylesheet 中。
- 只有浏览器自带样式 User Agent Style，CSSOM 构建包含在解析 HTML 中。

**构建 Render Tree**：浏览器只构建需要在屏幕上显示的部分。`<head>,<meta>,display:none`无需构建。`visibility：hidden`元素仍占据空间，需要构建。

1. 浏览器从 DOM 树开始，遍历每一个“可见”节点。
2. 对于每一个“可见”节点，在 CSSOM 上找到匹配的样式并应用。
3. 生成渲染树。

**Layout**：根据渲染树计算所有元素相对于 Viewport 的位置和大小，输出元素的盒模型。

**Paint**：浏览器将每一个节点以像素显示在屏幕上，最终我们看到页面。这一过程需要的时间与文档大小、CSS 样式的数量及复杂度、设备自身都有关。

#### 5.2 重排和重绘

##### 5.2.1 重排

**重排（reflow）**：又叫回流。当元素的位置发生变动的时候，浏览器重新执行布局这个步骤，来重新确定页面上内容的大小和位置。

会导致回流的操作：

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素内容变化、字体大小变化
- 添加或者删除**可见**的`DOM`元素
- 激活`CSS`伪类（例如：`:hover`）
- 查询某些属性或调用某些方法

一些常用且会导致回流的属性和方法：

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
- `scrollIntoView()`、`scrollIntoViewIfNeeded()`
- `getComputedStyle()`
- `getBoundingClientRect()`
- `scrollTo()`

##### 5.2.2 重绘

**重绘（repaint）**：如果元素位置没有发生变动，仅仅只是样式发生变动，这个时候浏览器重新渲染的时候会跳过布局步骤，直接进入绘制步骤。

会导致重绘的操作：

- 修改背景色、颜色（`background-color`、`color`）
- 设置可见度（`visibility`）
- 设置背景图（`background-image`）

##### 5.2.3 性能影响

**重排必将引起重绘，重绘不一定会引起重排。重排比重绘的代价要更高。**有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。

**如何避免？**

- 操作 DOM 时，尽量在低层级的 DOM 节点进行操作。
- 动画使用`absolute`定位或`fixed`定位，这样可以减少对其他元素的影响。
- 避免使用`table`布局，一个小的改动可能会使整个`table`进行重新布局。
- 避免使用`CSS`表达式（例如：`calc()`）。

- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
- 避免频繁操作`DOM`，可以创建一个文档片段`documentFragment`，在它上面应用所有 DOM 操作，最后再把它添加到文档中
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 使用`window.requestAnimationFrame()`，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。
- 使用虚拟 DOM（virtual DOM）库。

**现代浏览器**会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

#### 5.3 引入 JavaScript

**JS 是单线程**：JS 为处理页面中用户的交互以及操作 DOM 树、CSS 样式树这个使命而诞生。如果多线程，可能出现 UI 操作的冲突。

**JS 会阻塞 DOM 树的构建和渲染树的构建**：由于 JS 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。因此，浏览器设置 **GUI 渲染线程与 JS 引擎为互斥**的关系。当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中，等到 JS 引擎线程空闲时立即被执行。带 src 属性的`<script>`标签会触发页面 paint，渲染此`<script>`标签之前的元素。`<head>`中的`<script>`和 inline 的`<script>`标签不会触发页面 paint。

**CSS 不会阻塞 DOM 树的构建，会阻塞渲染树的构建和 JS 执行**：DOM 和 CSSOM 通常是并行构建，Render Tree 构建必须等待到 CSSOM 构建完成，也就是 CSS 资源加载完成。由于 JS 可能会请求样式信息，如果此时还没有加载和解析样式，JS 就有可能会得到错误的回复，所以需要等 CSSOM 构建完毕后再执行 JS。

**DOMContentLoaded 事件和 Load 事件**：DOM 解析完就会触发 DOMContentLoaded 事件；页面的 html、css、js、图片等资源都已经加载完之后才会触发 Load 事件。

#### 5.4 优化 CRP

**JavaScript**：

- 尽量将 JS 文件放在 body 的最后。

- 使用异步 js 脚本，添加`defer`或`async`属性，使加载 js 文件与渲染页面并行执行。

  - **defer**：当整个文档解析完毕后再执行脚本文件（保证脚本的执行顺序）

  - **async**：当脚本文件加载完毕后就开始执行脚本文件，最后回到 document 断点继续渲染。（不保证顺序）
  - 如果脚本之间有依赖关系，就使用`defer`属性；如果脚本之间没有依赖关系，就使用`async`属性；如果同时使用`async`和`defer`属性，由`async`属性决定。

![defer_async](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/7/16f7edfaa3e8c6ee~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

**CSS**：

- 用 `link` 替代`@import`，加载页面时，`link`标签引入的 CSS 被同时加载；`@import`引入的 CSS 将在页面加载完毕后被加载。
- 如果页面 css 较少，尽量使用内联。
- 将 CSS 放在页面开始位置。
- 降低选择器层级。

**HTML**：

- 降低 HTML 层级。
- 标签语义化。

---

## 2. 网络请求方式

XMLHttpRequest、ajax、fetch、axios

### 1. XMLHttpRequest

XMLHttpRequest 对象是浏览器提供的一个 API，用来向服务器发送请求并解析服务器响应，整个过程中，浏览器页面不会被刷新。

| 事件                 | 触发条件                                                                                                                                                                                                                                                                                                                                                                                                         |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `onreadystatechange` | 每当`xhr.readyState`改变时触发；但`xhr.readyState`由非`0`值变为`0`时不触发。                                                                                                                                                                                                                                                                                                                                     |
| `onloadstart`        | 调用`xhr.send()`方法后立即触发，若`xhr.send()`未被调用则不会触发此事件。                                                                                                                                                                                                                                                                                                                                         |
| `onprogress`         | `xhr.upload.onprogress`在上传阶段(即`xhr.send()`之后，`xhr.readystate=2`之前)触发，每 50ms 触发一次；`xhr.onprogress`在下载阶段（即`xhr.readystate=3`时）触发，每 50ms 触发一次。                                                                                                                                                                                                                                |
| `onload`             | 当请求成功完成时触发，此时`xhr.readystate=4`                                                                                                                                                                                                                                                                                                                                                                     |
| `onloadend`          | 当请求结束（包括请求成功和请求失败）时触发                                                                                                                                                                                                                                                                                                                                                                       |
| `onabort`            | 当调用`xhr.abort()`后触发                                                                                                                                                                                                                                                                                                                                                                                        |
| `ontimeout`          | `xhr.timeout`不等于 0，由请求开始即`onloadstart`开始算起，当到达`xhr.timeout`所设置时间请求还未结束即`onloadend`，则触发此事件。                                                                                                                                                                                                                                                                                 |
| `onerror`            | 在请求过程中，若发生`Network error`则会触发此事件（若发生`Network error`时，上传还没有结束，则会先触发`xhr.upload.onerror`，再触发`xhr.onerror`；若发生`Network error`时，上传已经结束，则只会触发`xhr.onerror`）。**注意**，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的`xhr.statusCode`是`4xx`时，并不属于`Network error`，所以不会触发`onerror`事件，而是会触发`onload`事件。 |

**方法**：

- `.open(method,url,async)`：准备启动一个 AJAX 请求；
- `.send(string)`：发送 AJAX 请求；
- `.getResponseHeader()`: 获得响应头部信息；
- `.getAllResponseHeader()`：获得一个包含所有头部信息的长字符串；
- `.abort()`：取消异步请求。XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。在终止请求之后，还应该对 XHR 对象进行解引用操作。由于内存原因，不建议重用 XHR 对象。
  - 会触发`$.ajax success`事件，所以在 success 是的回调函数需要添加判断 ajax 请求是否存在，存在才执行回调函数。
- `.setRequestHeader()`：设置请求头部信息；
  - `Accept`：浏览器能够处理的内容类型；
  - `Accept-Charset`: 浏览器能够显示的字符集；
  - `Accept-Encoding`：浏览器能够处理的压缩编码；
  - `Accept-Language`：浏览器当前设置的语言；
  - `Connection`：浏览器与服务器之间连接的类型；
  - `Cookie`：当前页面设置的任何 Cookie；
  - `Host`：发出请求的页面所在的域；
  - `Referer`：发出请求的页面 URI；
  - `User-Agent`：浏览器的用户代理字符串；

**属性**：

- `.responseText`：包含响应主体返回文本；
- `.responseXML`：如果响应的内容类型时`text/xml`或`application/xml`，该属性将保存包含着相应数据的 XML DOM 文档；
- `.status`：响应的 HTTP 状态；
- `.statusText`：HTTP 状态的说明；
- `.readyState`：表示“请求”/“响应”过程的当前活动阶段，可取值如下：
  - **0**：未初始化 -- 尚未调用`.open()`方法；
  - **1**：启动 -- 已经调用`.open()`方法，但尚未调用`.send()`方法；
  - **2**：发送 -- 已经调用`.send()`方法，但尚未接收到响应；
  - **3**：接收 -- 已经接收到部分响应数据；
  - **4**：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了；

**代码**：

```javascript
//创建XMLHttpRequest对象
var xhr
if (window.XMLHttpRequest) {
  //IE7+,Firefox，Chrome，Opera,Safari 执行
  xhr = new XMLHttpRequest()
} else {
  // IE6,IE5 执行
  xhr = new ActiveXObject('Microsoft.XMLHTTP')
}

// GET 请求
xhr.open('GET', 'url', true)
xhr.send()

// POST 请求
xhr.open('POST', 'url', true)
xhr.send()

//如果需要传参，则需要使用setRequestHeader() 来添加HTTP 头部
xhr.open('POST', 'url', true)
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')
xhr.send('name=tome&age=24')

// 通过 onreadystatechange  事件来监听状态变化，并获取服务器响应
xhr.onreadystatechange = function () {
  //请求成功时
  if (xhr.readyState == 4 && xhr.status == 200) {
    alert(xhr.responseText)
  }
}
```

**优点**：

- 不重新加载页面的情况下更新网页
- 在页面已加载后从服务器请求/接收数据
- 在后台向服务器发送数据。

**缺点**：

- 使用起来也比较繁琐，需要设置很多值
- 早期的 IE 浏览器有自己的实现，需要写兼容代码。

### 2. Ajax

Ajax 技术的核心是 XMLHttpRequest(简称 XHR)对象，XHR 为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步方式从服务器获取更多信息而不必刷新页面。

**完整 Ajax 请求流程**：

1. 准备 Ajax 请求

   - 创建`XMLHttpRequest`实例。

   - 设置监听`.onreadystatechange`事件，当`readyState`变换的时候触发。

   - 调用`open()`方法，设置请求方式，请求的 URL，等待响应的方式（同步或异步）

   - 调用`setRequestHeader()`设置请求头

2. 发送请求

   调用`send()`发送 Ajax 请求

3. 处理响应

   通过`status`属性判断请求是否成功，如果成功的话，则读取`responseText`属性中存储的返回值。

**Ajax 原生实现**：

```js
// 用Promise对象实现
var myAjax = function (url) {
  var promise = new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest()
    // 必须在open()方法之前指定事件处理程序，因为open()方法的执行也包含在该事件处理程序的监听范围之内。
    xhr.onreadystatechange = function () {
      if (xhr.readyState !== 4) return
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.responseText))
      } else {
        reject(new Error(xhr.statusText))
      }
    }
    xhr.open('POST', url, (async = true)) // 设置请求方式，请求的URL，等待响应的方式（同步=false / 异步=true）
    xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded') // post提交数据
    xhr.send()
  })
  return promise
}
myAjax('/posts.json')
  .then(json => {
    console.log(json)
  })
  .catch(err => {
    console.log(err)
  })
```

**jQuery $.ajax** 就是 XMLHttpRequest 对象的封装。它里面的 AJAX 请求也兼容了各浏览器，可以有简单易用的方法 get，post。

**代码**：

```javascript
$.ajax({
    type:'POST,
    url:'http://users/mine',
    data: data,
    dataType:dataType,
    success: function (){},
    error:function (){}
})
```

**优点**：

- 对原生 XHR 的封装，做了兼容处理，简化了使用。
- 增加了对 JSONP 的支持，可以简单处理部分跨域。

**缺点**：

- 如果有多个请求，并且有依赖关系的话，容易形成回调地狱。
- 本身是针对 MVC 的编程，不符合现在前端 MVVM 的浪潮。
- ajax 是 jQuery 中的一个方法。如果只是要使用 ajax 却要引入整个 jQuery 非常的不合理。

### 3. fetch

fetch 是一个低层次的 API，浏览器原生支持，XHR 的最新替代技术。

**代码**：

```javascript
fetch(url, {
  method: 'PUT',
  headers: {
    'Content-type': 'application/json'
  },
  body: data
})
  .then(res => res.json())
  .then(data => console.log(data))
```

**优点**

- 代码比 XMLHttpRequest 简洁很多，更加语义化；
- 基于标准 Promise 实现，支持 async/await；
- 更加底层，提供的 API 丰富。

**缺点**：

- API 偏底层，需要进行封装；
- fetch 只对网络请求报错，对 400、500 不会 reject；
- fetch 请求默认不带 cookie，通过手动添加 credentials：
  - omit：默认值，忽略 cookie 的发送
  - same-origin：表示 cookie 只能同域发送，不能跨域发送
  - include：cookie 既可以同域发送，也可以跨域发送
- 不支持 abort 和超时控制，使用 setTimeout/Promise.reject 实现的超时控制不能阻止请求过程继续在后台运行，造成流量浪费；
- 不支持原生监测请求的进度（大文件）。

### 4. axios

axios 是一个封装好的框架。

axios 是一个基于 Promise 用于浏览器（XHR）和 nodejs（http）的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本。

**代码**：

```javascript
axios({
  method: 'post',
  url: '/login',
  data: {
    username: 'jackson',
    password: 'yyqx1128'
  }
})
  .then(function (res) {
    console.log(res)
  })
  .catch(function (err) {
    console.log(err)
  })
```

**优点**：

- 支持从浏览器中创建`XMLHttpRequest` 和 从 node.js 中创建`http`请求
- 支持 `Promise API`，提供了并发请求的接口（Promise.all）
- 拦截请求和响应
- 转换请求数据和响应数据
- 支持中断请求
- 自动转换 `JSON` 数据
- 客户端支持防御 `XSRF`
- 支持请求进度监测

**缺点**：

- 只支持现代浏览器

**axios 拦截器实现**

```js
// 定义一个拦截器类
class Interceptors {
  constructor() {
    this.handlers = [] // 保存拦截器传入的回调
  }
  use(resolveHandler, rejectHandler) {
    this.handlers.push({
      resolveHandler,
      rejectHandler
    })
  }
}
export default Interceptors
```

```js
/* this代表axios实例指向 */
let promise = Promise.resolve(configs)
// 触发请求拦截器内的所有回调
this.interceptors.request.handlers.forEach(handler => {
  promise = promise.then(handler.resolveHandler, handler.rejectHandler)
})
// 发请求
promise = promise.then(this.dispatch, undefined)
// 触发响应拦截器所有回调
this.interceptors.response.handlers.forEach(handler => {
  promise = promise.then(handler.resolveHandler, handler.rejectHandler)
})
```
